module TypeForm
  use booltheory.BoolImplementation

  type atomicformula =
    | ATop
    | ABot
    | AVar i
  
  function eval_atomicformula (phi: atomicformula) (f: i -> t) : t
  = match phi with
      | ATop -> top
      | ABot -> bot
      | AVar i -> f i
    end
end

module Evals

  use TypeForm

  use import formula.ConjunctiveNormalForm as CNF 
  use import formula.Horn as HornFormula
  use import list.Mem as ListMem
  use list.List, list.Append, list.Length
  
  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option
 
  clone set.SetApp with type elt = atomicformula

  function eval_setconjunction (s: fset atomicformula) (f: i-> BoolImplementation.t) : BoolImplementation.t
  
  axiom eval_setconjunction_empty: forall f, s: fset atomicformula. is_empty s -> eval_setconjunction s f = top
 
  axiom eval_setconjunction_pick: forall f, s: fset atomicformula. not is_empty s -> forall x. mem x s ->
        eval_setconjunction s f = (eval_atomicformula x f) /*\ eval_setconjunction (remove x s) f 
        
  lemma eval_setconjunction_singleton: forall f, s: fset atomicformula. cardinal s = 1 -> 
      let x = pick s in eval_setconjunction s f = (eval_atomicformula x f)
   
   
  val function eq_pos (x y: atomicformula) : bool
    ensures { result <-> x = y }
  
  val function rs_eq_pos (x y: rightside) : bool
    ensures { result <-> x = y }  
      
  let rec lemma eval_commutes_add (s: set) (x: atomicformula) (f: i -> t)
    variant { cardinal (add x s) }
    ensures { eval_setconjunction (add x s) f = eval_atomicformula x f /*\ eval_setconjunction s f }
  = if is_empty s then ()
    else let y = choose (add x s) in
      if eq_pos x y then ()
      else let new_s = remove y (add x s) in
        eval_commutes_add new_s x f
      
  lemma add_eval: forall f s x. 
  eval_setconjunction (add x s) f = eval_atomicformula x f /*\ eval_setconjunction s f
   
  

  function eval_list (l: list (set, rightside)) (f: i-> BoolImplementation.t) : BoolImplementation.t
  = match l with
      | Nil -> top
      | Cons (t,r) l1 -> ((eval_setconjunction t f) ->* (eval_rightside (assign_rightside r f))) /*\ eval_list l1 f
    end

end

module Test

  use TypeForm
  use Evals

  use import formula.ConjunctiveNormalForm as CNF 
  use import formula.Horn as HornFormula
  use import list.Mem as ListMem
  use list.List, list.Append, list.Length
  
  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option
 
  clone set.SetApp with type elt = atomicformula
  
  let function convertRStoAF (phi: rightside) : atomicformula
    ensures {forall f. eval_rightside (assign_rightside phi f) = eval_atomicformula result f}
    ensures { match phi with
                | RProp t -> if t = top then result = ATop else result = ABot
                | RVar x -> result = AVar x
              end}
  = match phi with
      | RProp t -> if t = top then ATop else (ABot)
      | RVar x -> AVar x
    end
    
  let function convertPLtoAF (phi: pliteral) : atomicformula
    ensures{ match phi with
              | LBottom -> result = ABot
              | LVar x -> result = AVar x
            end }
  = match phi with
      | LBottom -> ABot
      | LVar x -> AVar x
    end  
 
  let function convertAFtoPL (phi: atomicformula) : pliteral
    requires{ phi <> ATop }
    ensures{ match phi with
              | ATop -> false
              | ABot -> result = LBottom
              | AVar x -> result = LVar x
            end }
  = match phi with
      | ATop -> absurd
      | ABot -> LBottom
      | AVar x -> LVar x
    end
    
    
  let function convertAFtoRS (phi: atomicformula) : rightside
    ensures { forall f. eval_atomicformula phi f = eval_rightside (assign_rightside result f)}
    ensures { match phi with
                | ATop -> result = RProp top
                | ABot -> result = RProp bot
                | AVar x -> result = RVar x
              end }
  = match phi with
      | ATop -> RProp top
      | ABot -> RProp bot
      | AVar x -> RVar x
    end
  
  
  (* LEMMAS *)
  
  (* lemma union_set: forall s:set. exists x:set, y:set. s = union x y *) 
       
  let rec lemma aux (s1: set) (s2: set) (f: i -> t)
   variant { cardinal s1 + cardinal s2 }
   ensures { eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f }
  = match is_empty s1, is_empty s2 with
    | True, True -> ()
    | False, True -> ()
    | True, False -> ()
    | False, False -> let element = choose s1 in aux (remove element s1) s2 f;
    assert { union s1 s2 == add element (union (remove element s1) s2) };
    assert { eval_setconjunction s1 f = eval_atomicformula element f /*\ eval_setconjunction (remove element s1) f }
     (*let s1 = union y1 y2; s2 = union x1 x2 in aux y1 y2 f; aux x1 x2 f*)
   end 
  
 (* lemma union_eval: forall s1 s2 f. eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f *)
  
  lemma union_eval_empty: forall s1 s2 f. s1 = empty /\ s2 = empty -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f
  
  lemma union_eval_samesingleton: forall s1 s2 e f. s1 = singleton e /\ s2 = singleton e -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f
    
  lemma union_eval_diffsingleton: forall s1 s2 e1 e2 f. e1 <> e2 /\ s1 = singleton e1 /\ s2 = singleton e2 -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f

  lemma convertPLtoAF_evaluation: forall f phi. eval_pliteral phi f = eval_atomicformula (convertPLtoAF phi) f
    
  lemma convertAFtoPL_evaluation: forall f phi. phi <> ATop -> eval_atomicformula phi f = eval_pliteral (convertAFtoPL phi) f
    
  lemma PLtoAF_AFtoPL: forall x. x <> ATop -> x = convertPLtoAF (convertAFtoPL x)
    
  lemma add_then_mem: forall x ns. ns = add (convertPLtoAF x) empty -> mem (convertPLtoAF x) ns
  
    
    
  function numberOfHBasic (phi: hornclause) : int
  = match phi with
      | HBasic _ -> 1
      | HAnd e1 e2 -> numberOfHBasic e1 + numberOfHBasic e2  
     end
  
  predicate op_and (x: pliteral) (phi: conj_pliteral) 
  = match phi with
    | CPL y -> y = x
    | CPAnd w z -> op_and x w \/ op_and x z
   end
  
  
  let rec function convertConjunctionToSet (phi: conj_pliteral) : set
  (* ensures{ forall y. mem y result -> op_and (convertAFtoPL y) phi }
   ensures{ forall y. op_and y phi -> (mem (convertPLtoAF y) result) } *)
  = match phi with
      | CPL pl -> singleton (convertPLtoAF pl)
      | CPAnd c1 c2 -> union (convertConjunctionToSet c1) (convertConjunctionToSet c2)
    end
    
    
  let rec lemma convertConjunctionToSet_lemma (y: pliteral) (phi: conj_pliteral)
    ensures { op_and y phi -> (mem (convertPLtoAF y) (convertConjunctionToSet phi)) }
  = match phi with
      | CPL _ -> ()
      | CPAnd c1 c2 -> convertConjunctionToSet_lemma y c1; convertConjunctionToSet_lemma y c2
     end
     
  let rec lemma convertConjunctionToSet_lemma1 (y: atomicformula) (phi: conj_pliteral)
    ensures { mem y (convertConjunctionToSet phi) -> op_and (convertAFtoPL y) phi }
  = match phi with
      | CPL _ -> ()
      | CPAnd c1 c2 -> convertConjunctionToSet_lemma1 y c1; convertConjunctionToSet_lemma1 y c2
     end
    
  goal pp_same_p: forall x y f. HornFormula.eval_positive (CPAnd (CPL x) (CPL y)) f = eval_setconjunction (union (singleton (convertPLtoAF y)) (singleton (convertPLtoAF x))) f
    
  let rec lemma eval_equivalent (phi: conj_pliteral) (f: i -> t)
    variant { phi }
    ensures { let s = convertConjunctionToSet phi in HornFormula.eval_positive phi f = eval_setconjunction s f }
  = match phi with
      | CPL _ -> () (* assert{ convertConjunctionToSet phi = singleton (convertPLtoAF x) } *)
      | CPAnd z w -> eval_equivalent z f; eval_equivalent w f
     end
   
    
  let rec function convertToSet (phi: leftside) : set
    ensures{ phi = LTop -> result = singleton ATop }
    ensures{ forall c. phi = LPos c -> result = convertConjunctionToSet c }
  = match phi with
      | LTop -> singleton ATop
      | LPos c -> convertConjunctionToSet c
    end  
    
    
  let rec function convertToList (phi: hornclause) : list (set, rightside)
    ensures{ forall l r. phi = HBasic (BImpl l r) -> ListMem.mem (convertToSet l, r) result }
    ensures{ length result = numberOfHBasic phi }
  = match phi with
      | HBasic (BImpl l r) -> Cons ((convertToSet l), r) Nil
      | HAnd e1 e2 -> (convertToList e1) ++ (convertToList e2)
    end
    
  
  predicate not_subset_in_findFirst (listformula: list (set,rightside)) (s: set)
  = match listformula with
      | Nil -> true
      | Cons (l,_) lst -> (not subset l s) /\ not_subset_in_findFirst lst s
     end
    
    
  let rec function findFirst (listformula: list (set,rightside)) (s: set) : (left: list (set,rightside), right:  list (set,rightside))
    variant { length listformula }
    ensures { left ++ right = listformula }
    ensures { match right with
                | Nil -> not_subset_in_findFirst listformula s
                | Cons (l,_) _ -> subset l s
               end }
  = match listformula with
      | Nil -> (Nil,Nil)
      | Cons (l,r) lst -> if subset l s then (Nil , Cons (l,r) lst) 
            else let (le,ri) = findFirst lst s in
              (Cons (l,r) le, ri)
     end
       
  function set_from_listformula (listformula: list (set,rightside)) : fset atomicformula
  = match listformula with
      | Nil -> empty
      | Cons (_,r) lst -> add (convertRStoAF r) (set_from_listformula lst)
     end

     
  predicate if_subset_then_mem_result (listformula: list (set,rightside)) (s result: set)
  = match listformula with
      | Nil -> true
      | Cons ( leftset , p ) l -> if (subset leftset s) then mem (convertRStoAF p) result /\ if_subset_then_mem_result l s result
      else if_subset_then_mem_result l s result     
    end
    
  let function algorithmA_basic (clause: (set,rightside)) (s: set) : set
    requires { mem ATop s }
    ensures { let (leftset, p) = clause in
      if (subset leftset s) then
        result = add (convertRStoAF p) s
      else
        result = s }
  = let (leftset, p) = clause in
      if (subset leftset s) then
        add (convertRStoAF p) s
      else
        s
        
  let rec function algorithmA (listformula: list (set,rightside)) (s: set) : set
    requires { mem ATop s }
    variant { length listformula }
    ensures { match listformula with
      | Nil -> result = s
      | Cons x Nil -> result = algorithmA_basic x s
      | _ -> let (left,right) = findFirst listformula s in
              match right with
                  | Nil -> result = s
                  | Cons (_,r) lst -> result = (add (convertRStoAF r) s)
                 end
      end }
  = match listformula with
      | Nil -> s
      | Cons x Nil -> algorithmA_basic x s
      | _ -> let (left,right) = findFirst listformula s in
                match right with
                  | Nil -> s
                  | Cons (_,r) lst -> algorithmA (left ++ lst) (add (convertRStoAF r) s)
                 end
    end
        
  function eval_hornclause_element (phi: (set, rightside)) (f: i -> t) : t
  = let (leftset, p) = phi in (eval_setconjunction (leftset) f) /*\ (eval_rightside (assign_rightside p f))
  
  function eval_hornclause_list (phi: list (set, rightside)) (f: i -> t) : t
  = match phi with
      | Nil -> top
      | Cons x Nil -> eval_hornclause_element x f
      | Cons x l -> eval_hornclause_element x f /*\ eval_hornclause_list l f
    end
    
  predicate is_satisfiable (s: list (set, rightside))
  = exists f. eval_hornclause_list s f = top
        
  predicate is_unsatisfiable_set (s: set)
  = forall f. eval_setconjunction s f <> top
  
  predicate is_satisfiable_set (s: set)
  = exists f. eval_setconjunction s f = top
        
  predicate is_satisfiable_rs (phi: rightside)
  = exists f. (eval_rightside (assign_rightside phi f)) = top        
        
  predicate is_unsatisfiable_rs (phi: rightside)
  = forall f. (eval_rightside (assign_rightside phi f)) <> top      
        
  predicate is_satisfiable_clause (phi: (set, rightside))
  = exists f. let (leftset, p) = phi in (eval_setconjunction leftset f = top /\ is_satisfiable_rs p) \/ (is_unsatisfiable_set leftset)
  
  
  
  
  lemma case_clause_basic: forall phi p s. is_satisfiable_clause phi /\ phi = (s,p) -> not mem ABot (algorithmA_basic phi (mk (singleton ATop)))
  lemma case_clause: forall phi s p. is_satisfiable phi /\ phi = Cons (s,p) Nil -> not mem ABot (algorithmA phi (mk (singleton ATop)))
  lemma case_induction: forall phi. is_satisfiable phi -> not mem ABot (algorithmA phi (mk (singleton ATop)))

end

module Horn
  use TypeForm
  use Evals

  use import formula.ConjunctiveNormalForm as CNF 
  use import formula.Horn as HornFormula
  use import list.Mem as ListMem
  use list.List, list.Append, list.Length
  
  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option
 
  clone set.SetApp with type elt = atomicformula
  
  let function convertRStoAF (phi: rightside) : atomicformula
    ensures {forall f. eval_rightside (assign_rightside phi f) = eval_atomicformula result f}
    ensures { match phi with
                | RProp t -> if t = top then result = ATop else result = ABot
                | RVar x -> result = AVar x
              end}
  = match phi with
      | RProp t -> if t = top then ATop else (ABot)
      | RVar x -> AVar x
    end
    
  let function convertPLtoAF (phi: pliteral) : atomicformula
    ensures{ match phi with
              | LBottom -> result = ABot
              | LVar x -> result = AVar x
            end }
  = match phi with
      | LBottom -> ABot
      | LVar x -> AVar x
    end  
 
  let function convertAFtoPL (phi: atomicformula) : pliteral
    requires{ phi <> ATop }
    ensures{ match phi with
              | ATop -> false
              | ABot -> result = LBottom
              | AVar x -> result = LVar x
            end }
  = match phi with
      | ATop -> absurd
      | ABot -> LBottom
      | AVar x -> LVar x
    end
    
    
  let function convertAFtoRS (phi: atomicformula) : rightside
    ensures { forall f. eval_atomicformula phi f = eval_rightside (assign_rightside result f)}
    ensures { match phi with
                | ATop -> result = RProp top
                | ABot -> result = RProp bot
                | AVar x -> result = RVar x
              end }
  = match phi with
      | ATop -> RProp top
      | ABot -> RProp bot
      | AVar x -> RVar x
    end
  
  
  (* LEMMAS *)
  
  (* lemma union_set: forall s:set. exists x:set, y:set. s = union x y *) 
       
  let rec lemma aux (s1: set) (s2: set) (f: i -> t)
   variant { cardinal s1 + cardinal s2 }
   ensures { eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f }
  = match is_empty s1, is_empty s2 with
    | True, True -> ()
    | False, True -> ()
    | True, False -> ()
    | False, False -> let element = choose s1 in aux (remove element s1) s2 f;
    assert { union s1 s2 == add element (union (remove element s1) s2) };
    assert { eval_setconjunction s1 f = eval_atomicformula element f /*\ eval_setconjunction (remove element s1) f }
     (*let s1 = union y1 y2; s2 = union x1 x2 in aux y1 y2 f; aux x1 x2 f*)
   end 
  
 (* lemma union_eval: forall s1 s2 f. eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f *)
  
  lemma union_eval_empty: forall s1 s2 f. s1 = empty /\ s2 = empty -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f
  
  lemma union_eval_samesingleton: forall s1 s2 e f. s1 = singleton e /\ s2 = singleton e -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f
    
  lemma union_eval_diffsingleton: forall s1 s2 e1 e2 f. e1 <> e2 /\ s1 = singleton e1 /\ s2 = singleton e2 -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f

  lemma convertPLtoAF_evaluation: forall f phi. eval_pliteral phi f = eval_atomicformula (convertPLtoAF phi) f
    
  lemma convertAFtoPL_evaluation: forall f phi. phi <> ATop -> eval_atomicformula phi f = eval_pliteral (convertAFtoPL phi) f
    
  lemma PLtoAF_AFtoPL: forall x. x <> ATop -> x = convertPLtoAF (convertAFtoPL x)
    
  lemma add_then_mem: forall x ns. ns = add (convertPLtoAF x) empty -> mem (convertPLtoAF x) ns
  
    
    
  function numberOfHBasic (phi: hornclause) : int
  = match phi with
      | HBasic _ -> 1
      | HAnd e1 e2 -> numberOfHBasic e1 + numberOfHBasic e2  
     end
  
  predicate op_and (x: pliteral) (phi: conj_pliteral) 
  = match phi with
    | CPL y -> y = x
    | CPAnd w z -> op_and x w \/ op_and x z
   end
  
  
  let rec function convertConjunctionToSet (phi: conj_pliteral) : set
  (* ensures{ forall y. mem y result -> op_and (convertAFtoPL y) phi }
   ensures{ forall y. op_and y phi -> (mem (convertPLtoAF y) result) } *)
  = match phi with
      | CPL pl -> singleton (convertPLtoAF pl)
      | CPAnd c1 c2 -> union (convertConjunctionToSet c1) (convertConjunctionToSet c2)
    end
    
    
  let rec lemma convertConjunctionToSet_lemma (y: pliteral) (phi: conj_pliteral)
    ensures { op_and y phi -> (mem (convertPLtoAF y) (convertConjunctionToSet phi)) }
  = match phi with
      | CPL _ -> ()
      | CPAnd c1 c2 -> convertConjunctionToSet_lemma y c1; convertConjunctionToSet_lemma y c2
     end
     
  let rec lemma convertConjunctionToSet_lemma1 (y: atomicformula) (phi: conj_pliteral)
    ensures { mem y (convertConjunctionToSet phi) -> op_and (convertAFtoPL y) phi }
  = match phi with
      | CPL _ -> ()
      | CPAnd c1 c2 -> convertConjunctionToSet_lemma1 y c1; convertConjunctionToSet_lemma1 y c2
     end
    
  goal pp_same_p: forall x y f. HornFormula.eval_positive (CPAnd (CPL x) (CPL y)) f = eval_setconjunction (union (singleton (convertPLtoAF y)) (singleton (convertPLtoAF x))) f
    
  let rec lemma eval_equivalent (phi: conj_pliteral) (f: i -> t)
    variant { phi }
    ensures { let s = convertConjunctionToSet phi in HornFormula.eval_positive phi f = eval_setconjunction s f }
  = match phi with
      | CPL _ -> () (* assert{ convertConjunctionToSet phi = singleton (convertPLtoAF x) } *)
      | CPAnd z w -> eval_equivalent z f; eval_equivalent w f
     end
   
    
  let rec function convertToSet (phi: leftside) : set
    ensures{ phi = LTop -> result = singleton ATop }
    ensures{ forall c. phi = LPos c -> result = convertConjunctionToSet c }
  = match phi with
      | LTop -> singleton ATop
      | LPos c -> convertConjunctionToSet c
    end  
    
    
  let rec function convertToList (phi: hornclause) : list (set, rightside)
    ensures{ forall l r. phi = HBasic (BImpl l r) -> ListMem.mem (convertToSet l, r) result }
    ensures{ length result = numberOfHBasic phi }
  = match phi with
      | HBasic (BImpl l r) -> Cons ((convertToSet l), r) Nil
      | HAnd e1 e2 -> (convertToList e1) ++ (convertToList e2)
    end
    
  
  predicate not_subset_in_findFirst (listformula: list (set,rightside)) (s: set)
  = match listformula with
      | Nil -> true
      | Cons (l,_) lst -> (not subset l s) /\ not_subset_in_findFirst lst s
     end
    
    
  let rec function findFirst (listformula: list (set,rightside)) (s: set) : (left: list (set,rightside), right:  list (set,rightside))
    variant { length listformula }
    ensures { left ++ right = listformula }
    ensures { match right with
                | Nil -> not_subset_in_findFirst listformula s
                | Cons (l,_) _ -> subset l s
               end }
  = match listformula with
      | Nil -> (Nil,Nil)
      | Cons (l,r) lst -> if subset l s then (Nil , Cons (l,r) lst) 
            else let (le,ri) = findFirst lst s in
              (Cons (l,r) le, ri)
     end
       
  function set_from_listformula (listformula: list (set,rightside)) : fset atomicformula
  = match listformula with
      | Nil -> empty
      | Cons (_,r) lst -> add (convertRStoAF r) (set_from_listformula lst)
     end
     
  predicate rightside_in_formula (rs: rightside) (listformula: list (set,rightside))
  = match listformula with
      | Nil -> false
      | Cons ( _ , p ) l -> if (rs_eq_pos p rs) then true
                            else rightside_in_formula rs l
     end
     
  predicate if_subset_then_mem_result_clause (clause: (set,rightside)) (s result: set)
  = let (leftset, p) = clause in
      if( subset leftset s ) then
        mem (convertRStoAF p) result
      else result = s
      
      
  function algorithmA_basic (clause: (fset atomicformula,rightside)) (s: fset atomicformula) : fset atomicformula
  = let (leftset, p) = clause in
      if (subset leftset (s)) then
        (add (convertRStoAF p) s)
      else
        s
        
  let algorithmA_basic (clause: (set,rightside)) (s: set) : set
    requires { mem ATop s }
    ensures { if_subset_then_mem_result_clause clause s result }
    ensures { subset s result }
    ensures { let (leftside, p) = clause in result = algorithmA_basic (to_fset leftside,p) s }
  = let (leftset, p) = clause in
      if (subset leftset s) then
        add (convertRStoAF p) s
      else
        s

    
  predicate all_elements_from_set_in_formula (listformula: list (set,rightside)) (result: set)
  = forall x. x <> ATop /\ mem x result -> rightside_in_formula (convertAFtoRS x) listformula
     
  predicate if_subset_then_mem_result (listformula: list (set,rightside)) (s result: set)
  = match listformula with
      | Nil -> false
      | Cons x Nil -> if_subset_then_mem_result_clause x s result
      | Cons ( leftset , p ) l -> if (subset leftset s) then mem (convertRStoAF p) result /\ if_subset_then_mem_result l s result
                                  else if_subset_then_mem_result l s result     
    end
    
 
  
  let rec function algorithmA (listformula: list (set,rightside)) (s: set) : set
    requires { listformula <> Nil }
    requires { mem ATop s }
    variant{ length listformula }
    ensures{ if_subset_then_mem_result listformula s result }
    (*ensures{ all_elements_from_set_in_formula listformula result }*)
  = match listformula with
      | Cons x Nil -> algorithmA_basic x s
      | _ -> let (left,right) = findFirst listformula s in
                match right with
                  | Nil -> s
                  | Cons (_,r) lst -> algorithmA (left ++ lst) (add (convertRStoAF r) s)
                 end
    end
     
  let function horn (phi: hornclause) (s: set) : BoolImplementation.t
  = let result_set = (algorithmA (convertToList phi) (singleton ATop)) in
      if(mem ABot result_set) then bot else top
  
  predicate is_satisfiable (phi: hornclause)
  = exists f. eval_hornclause phi f = top
  
  predicate is_satisfiable_rs (phi: rightside)
  = exists f. (eval_rightside (assign_rightside phi f)) = top
  
  predicate is_satisfiable_ls (phi: leftside)
  = exists f. (eval_leftside phi f) = top
  
  predicate is_unsatisfiable_rs (phi: rightside)
  = forall f. (eval_rightside (assign_rightside phi f)) <> top
  
  predicate has_bottom (phi: list (set, rightside)) 
  = match phi with
      | Nil -> false
      | Cons (l,r) lst -> if r = RProp bot then true else has_bottom lst
     end 
     
  lemma if_unsat_then_not_sat: forall p. is_unsatisfiable_rs p -> not is_satisfiable_rs p
     
  lemma singleton: (singleton ATop) = (singleton ATop)
  
  (* lemma algorithmA: forall phi. algorithmA (convertToList phi) (singleton ATop) = algorithmA (convertToList phi) ((singleton ATop)) *)
    
  lemma satisf: forall phi p. phi = HBasic (BImpl LTop p) /\ is_satisfiable phi -> is_satisfiable_ls LTop /\ is_satisfiable_rs p
  
  constant id_val: i -> t = fun _ -> top
  
  lemma top_is_satisfiable: forall p. p = RProp top -> is_satisfiable_rs p
  
  lemma bot_is_unsatisfiable: forall p. p = RProp bot -> is_unsatisfiable_rs p
    
  lemma if_satisf_then_not_bottom: forall p. is_satisfiable_rs p -> p <> RProp bot
    
  lemma check1: forall phi p. is_satisfiable phi /\ phi = HBasic (BImpl LTop p) -> length (convertToList phi) = 1
  
  (* goal A0: not mem ABot ( algorithmA (Nil) (mk (singleton ATop) )) *)
  
  goal A1: not mem ABot (algorithmA_basic ((singleton ATop), RProp top) ((singleton ATop)))
  
  lemma case1_with_basic: forall phi p. is_satisfiable phi /\ phi = HBasic (BImpl LTop p) -> is_satisfiable_rs p /\ not mem ABot (algorithmA_basic ((to_fset (convertToSet LTop)), p) (mk (singleton ATop)))
  
  lemma case2_with_basic: forall phi p c. is_satisfiable phi /\ phi = HBasic (BImpl c p) -> not mem ABot (algorithmA_basic ((to_fset (convertToSet c)), p) (mk (singleton ATop)))
     
  lemma case1: forall phi p. is_satisfiable phi /\ phi = HBasic (BImpl LTop p) -> is_satisfiable_rs p /\ not mem ABot (algorithmA (convertToList phi) (mk (singleton ATop)))
     
  (*lemma f1: forall phi. let philist = convertToList phi in has_bottom philist /\ (mem ABot (algorithmA philist (mk (singleton ATop)))) -> not is_satisfiable phi
  
  lemma f2_1: forall phi. is_satisfiable phi -> not mem ABot (algorithmA (convertToList phi) (mk (singleton ATop)))
  
  lemma f2_2: forall phi. not is_satisfiable phi -> mem ABot (algorithmA (convertToList phi) (mk (singleton ATop)))*)
  
  (*
  goal convertSet_Top: convertToSet(     LTop     ) == add (ATop) empty
  goal convertSet_Bottom: convertToSet(     (LPos (CPL LBottom))     ) == add (ABot) empty
  goal convertSet_Variable: forall x. convertToSet(     (LPos (CPL (LVar x)))     ) == add (AVar x) empty
  goal convertSet_And_Bot_Bot: convertToSet(     (LPos (CPAnd (CPL LBottom) (CPL LBottom)))     ) == add (ABot) empty
  goal convertSet_And_X_Y: forall x y. convertToSet(     (LPos (CPAnd (CPL (LVar x)) (CPL (LVar y))))     ) == add (AVar x) (add (AVar y) empty)
  goal convertSet_And_X_X: forall x. convertToSet(     (LPos (CPAnd (CPL (LVar x)) (CPL (LVar x))))     ) == add (AVar x) empty
  goal convertSet_And_X_Y_Z: forall x y z. convertToSet(     (LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar y))) (CPL (LVar z))))     ) == add (AVar x) (add (AVar y) (add (AVar z) empty))
  goal convertSet_And_X_X_Y_Z: forall x y z. convertToSet(     (LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar x))) (CPAnd (CPL (LVar y)) (CPL (LVar z)))))     ) == add (AVar x) (add (AVar y) (add (AVar z) empty))
  goal convertSet_And_X_Y_W_Z: forall x y w z. convertToSet(     (LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar y))) (CPAnd (CPL (LVar w)) (CPL (LVar z)))))     ) == add (AVar x) (add (AVar y) (add (AVar z) (add (AVar w) empty)))
 *)
 (*
  goal convertList_Basic_Impl_Top_Bot: convertToList (HBasic (BImpl (LTop) (RProp bot))) = Cons ((singleton ATop), RProp bot) Nil
  goal convertList_Basic_Impl_Top_Var: forall x. convertToList (HBasic (BImpl (LTop) (RVar x))) = Cons ((add ATop empty), RVar x) Nil
  goal convertList_Basic_Impl_AndBotBot_Bot: convertToList (HBasic (BImpl ((LPos (CPAnd (CPL LBottom) (CPL LBottom)))) (RProp bot))) = Cons (union (add (ABot) empty) (add (ABot) empty ), RProp bot) Nil
  goal convertList_Basic_Impl_AndBotBot_Var: forall x. convertToList (HBasic (BImpl ((LPos (CPAnd (CPL LBottom) (CPL LBottom)))) (RVar x))) = Cons (union (add (ABot) empty) (add (ABot) empty ), RVar x) Nil
  goal convertList_Basic_Impl_AndXY_Bot: forall x y. convertToList (HBasic (BImpl ((LPos (CPAnd (CPL (LVar x)) (CPL (LVar y))))) (RProp bot))) = Cons (union (add (AVar x) empty) (add (AVar y) empty ), RProp bot) Nil
  goal convertList_Basic_Impl_AndXY_Top: forall x y. convertToList (HBasic (BImpl ((LPos (CPAnd (CPL (LVar x)) (CPL (LVar y))))) (RProp top))) = Cons (union (add (AVar x) empty) (add (AVar y) empty ), RProp top) Nil
  goal convertList_Basic_Impl_AndXX_Bot: forall x. convertToList (HBasic (BImpl ((LPos (CPAnd (CPL (LVar x)) (CPL (LVar x))))) (RProp bot))) = Cons (union (add (AVar x) empty) (add (AVar x) empty ), RProp bot) Nil
  goal convertList_Basic_Impl_AndXX_Top: forall x. convertToList (HBasic (BImpl ((LPos (CPAnd (CPL (LVar x)) (CPL (LVar x))))) (RProp top))) = Cons (union (add (AVar x) empty) (add (AVar x) empty ), RProp top) Nil
  goal convertList_Basic_Impl_AndXYZ_Bot: forall x y z. convertToList (HBasic (BImpl ((LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar y))) (CPL (LVar z))))) (RProp bot))) = Cons (union (union (add (AVar x) empty) (add (AVar y) empty)) (add (AVar z) empty ), RProp bot) Nil
  goal convertList_Basic_Impl_AndXYZ_Top: forall x y z. convertToList (HBasic (BImpl ((LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar y))) (CPL (LVar z))))) (RProp top))) = Cons (union (union (add (AVar x) empty) (add (AVar y) empty)) (add (AVar z) empty ), RProp top) Nil
  goal convertList_Basic_Impl_AndXXYZ_Bot: forall x y z. convertToList (HBasic (BImpl ((LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar x))) (CPAnd (CPL (LVar y)) (CPL (LVar z)))))) (RProp bot))) = Cons (union (union (add (AVar x) empty) (add (AVar x) empty)) (union (add (AVar y) empty) (add (AVar z) empty) ), RProp bot) Nil
  goal convertList_Basic_Impl_AndXXYZ_Top: forall x y z. convertToList (HBasic (BImpl ((LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar x))) (CPAnd (CPL (LVar y)) (CPL (LVar z)))))) (RProp top))) = Cons (union (union (add (AVar x) empty) (add (AVar x) empty)) (union (add (AVar y) empty) (add (AVar z) empty) ), RProp top) Nil
  goal convertList_Basic_Impl_AndXYWZ_Bot: forall x y w z. convertToList (HBasic (BImpl ((LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar y))) (CPAnd (CPL (LVar w)) (CPL (LVar z)))))) (RProp bot))) = Cons (union (union (add (AVar x) empty) (add (AVar y) empty)) (union (add (AVar w) empty) (add (AVar z) empty) ), RProp bot) Nil
  goal convertList_Basic_Impl_AndXYWZ_Top: forall x y w z. convertToList (HBasic (BImpl ((LPos (CPAnd (CPAnd (CPL (LVar x)) (CPL (LVar y))) (CPAnd (CPL (LVar w)) (CPL (LVar z)))))) (RProp top))) = Cons (union (union (add (AVar x) empty) (add (AVar y) empty)) (union (add (AVar w) empty) (add (AVar z) empty) ), RProp top) Nil
  *)

end

