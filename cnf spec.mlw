let rec impl_free_cps (phi: formula) (k: formula_wi -> 'a ) : 'a
    variant{ phi }
    ensures{ post k (impl_free phi) result}
  = match phi with
    | Prop t -> if t = bot then k (L_wi (LBottom))
                else k (FNeg_wi (L_wi LBottom))
    | Var i -> k (L_wi (LVar i))
    | Neg phi1 -> 
        impl_free_cps phi1 (fun processed_phi1 -> ensures { post k (KNeg_wi processed_phi1) result }
            k (FNeg_wi processed_phi1))
    | Or phi1 phi2 -> 
        impl_free_cps phi1 (fun impl_left -> ensures { post k (FOr_wi impl_left (impl_free phi2)) result }
        impl_free_cps phi2 (fun impl_right -> ensures { post k (FOr_wi impl_left impl_right) result }
            k (FOr_wi impl_left impl_right)))
    | And phi1 phi2 -> 
        impl_free_cps phi1 (fun impl_left -> ensures { post k (FAnd_wi impl_left (impl_free phi2)) result }
        impl_free_cps phi2 (fun impl_right -> ensures { post k (FAnd_wi impl_left impl_right) result }
            k (FAnd_wi impl_left impl_right)))
    | Impl phi1 phi2 -> 
        impl_free_cps phi1 (fun impl_left -> ensures { post k (FOr_wi (FNeg_wi impl_left) (impl_free phi2)) result }
        impl_free_cps phi2 (fun impl_right -> ensures { post k (FOr_wi (FNeg_wi impl_left) impl_right) result }
            k (FOr_wi (FNeg_wi impl_left) impl_right)))
    end