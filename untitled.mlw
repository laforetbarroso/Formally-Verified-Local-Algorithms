let rec impl_free_cps (phi: formula) (k: formula_wi -> 'a ) : 'a
    variant{ phi }
    ensures{ post k (impl_free phi) result}
  = match phi with
    | Prop t -> if t = bot then k (L_wi (LBottom))
                else k (FNeg_wi (L_wi LBottom))
    | Var i -> k (L_wi (LVar i))
    | Neg phi1 -> 
        impl_free_cps phi1 (fun con -> ensures { post k (KNeg_wi con) result }
          k (FNeg_wi con))
    | Or phi1 phi2 -> 
        impl_free_cps phi1 (fun con -> ensures { post k (FOr_wi con (impl_free phi2)) result }
        impl_free_cps phi2 (fun con1 -> ensures { post k (FOr_wi con con1) result }
          k (FOr_wi con con1)))
    | And phi1 phi2 -> 
        impl_free_cps phi1 (fun con -> ensures { post k (FAnd_wi con (impl_free phi2)) result }
        impl_free_cps phi2 (fun con1 -> ensures { post k (FAnd_wi con con1) result }
          k (FAnd_wi con con1)))
    | Impl phi1 phi2 -> 
        impl_free_cps phi1 (fun con -> ensures { post k (FOr_wi (FNeg_wi con) (impl_free phi2)) result }
        impl_free_cps phi2 (fun con1 -> ensures { post k (FOr_wi (FNeg_wi con) con1) result }
          k (FOr_wi (FNeg_wi con) con1)))
    end

  let impl_free_main (phi: formula) : formula_wi
    ensures{forall f. eval phi f = eval_wi result f}
  = impl_free_cps phi (fun x -> x)