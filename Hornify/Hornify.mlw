module Types

  type ident

  (* Conjunctive Normal Form *)    

  type pliteral =
      | LBottom
      | LVar ident

  type clause_cnf =
      | DLiteral pliteral
      | DNeg_cnf pliteral
      | DOr_cnf clause_cnf clause_cnf
      
  type formula_cnf =
      | FClause_cnf clause_cnf
      | FAnd_cnf formula_cnf formula_cnf


  (* Horn Formula *)    

  type rightside =
      | RBottom
      | RTop
      | RVar ident

  type positive =
      | PLCBottom
      | PLCVar ident
      | PLCAnd positive positive

  type leftside = 
      | LTop
      | LPos positive

  type basichornclause =
      | BImpl leftside rightside

  type hornclause =
      | HBasic basichornclause
      | HAnd hornclause hornclause

end



module Valuation

  use option.Option, int.Int, bool.Bool, Types
  
  clone export set.SetApp with type elt = positive
  
  use import set.Fset as FS
  
  type valuation = ident -> bool
  
  
  (* CNF Valuation *)

  let function eval_literal (v: valuation) (l: pliteral) : bool
  = match l with
      | LBottom -> false
      | LVar x -> v x
    end 

  let rec function eval_disj_cnf (v: valuation) (phi: clause_cnf) : bool
  = match phi with
      | DLiteral l -> eval_literal v l
      | DNeg_cnf l -> not eval_literal v l
      | DOr_cnf phi1 phi2 -> eval_disj_cnf v phi1 || eval_disj_cnf v phi2
    end
    
  let rec function eval_formula_cnf (v: valuation) (phi: formula_cnf) : bool
  = match phi with
      | FClause_cnf phi1 -> eval_disj_cnf v phi1
      | FAnd_cnf phi1 phi2 -> eval_formula_cnf v phi1 && eval_formula_cnf v phi2
    end
    
    
  (* Horn Valuation *)  
    
  let function eval_rightside (v: valuation) (r: rightside) : bool
  = match r with
      | RBottom -> false
      | RTop -> true
      | RVar x -> v x
    end
    
  let rec function eval_positive (v: valuation) (plc: positive) : bool
  = match plc with
      | PLCBottom -> false
      | PLCVar x -> v x
      | PLCAnd phi1 phi2 -> eval_positive v phi1 && (eval_positive v phi2)
    end
    
  let rec function eval_leftside (v: valuation) (l: leftside) : bool
  = match l with
      | LTop -> true
      | LPos phi1 -> eval_positive v phi1
    end
    
  let rec function eval_basichornclause (v: valuation) (b: basichornclause) : bool
  = match b with
      | BImpl left right -> implb (eval_leftside v left) (eval_rightside v right)
    end
    
  let rec function eval_hornclause (v: valuation) (h: hornclause) : bool
  = match h with
      | HBasic h1 -> eval_basichornclause v h1
      | HAnd h1 h2 -> eval_hornclause v h1 && eval_hornclause v h2
    end

  
  (* Sets e Option Valuation *)
    
  function eval_optionrightside (v: valuation) (p: option rightside) : bool
  = match p with
      | None -> false
      | Some x -> eval_rightside v x
    end
  
  let rec ghost function eval_set (v: valuation) (s: fset positive) : bool
  variant{FS.cardinal s}
  = if FS.is_empty s then
      false
    else
      if FS.cardinal s = 1 then 
        not (eval_positive v (FS.pick s)) 
      else 
        let x = FS.pick s in
           (not (eval_positive v x) || eval_set v (FS.remove x s)) 
   
  let rec ghost function eval_conjunction_set (v: valuation) (s: fset positive) : bool
  variant{FS.cardinal s}
  = if(FS.is_empty s) then 
      false
    else
      if FS.cardinal s = 1 then 
        eval_positive v (FS.pick s) 
      else
        let x = FS.pick s in
          (eval_positive v x && eval_conjunction_set v (FS.remove x s))
       
  (* Domain and Codomain Valuation *)

  function eval_domain (v: valuation) (phi: clause_cnf) (s: set) (p: option rightside) : bool
  = eval_disj_cnf v phi || eval_set v s || eval_optionrightside v p
  
  function eval_codomain (v: valuation) (s: set) (p: option rightside) : bool
  = eval_set v s || eval_optionrightside v p



end





module Lemmas

  use option.Option, int.Int, bool.Bool, Types, Valuation
  
  use import set.Fset as FS
       
  
  (*
  lemma notempty: forall v s. (eval_set v s = true) -> s <> empty
  lemma onet: forall v x. let s = add (x) empty in eval_set v s = true -> (not eval_positiveliteral_conj v (choose s)) = true
  lemma onetrue: forall v s. (eval_set v s = true) /\ (cardinal s = 1) -> (not eval_positiveliteral_conj v (choose s)) = true
  lemma onetrue2: forall v s. (eval_set v s = true) -> exists x. (mem x s) = true /\ (not eval_positiveliteral_conj v x) = true
  lemma setfalse: forall v s. (eval_set v s = false) ->
  
  lemma elAbs1: forall v s. eval_set v (add (PLCBottom) s) = true
  lemma elAbs2: forall v s x. (not (eval_positiveliteral_conj v x)) = true -> eval_set v (add (x) s) = true
  lemma elNeu1: forall v s x. (not (eval_positiveliteral_conj v x)) = false -> eval_set v (add (x) s) = eval_set v s
  
  lemma distr: forall v s1 s2. eval_set v (union s1 s2) = eval_set v s1 || eval_set v s2
  
  lemma a: forall v s x. ((eval_set v s) = true -> (eval_set v (add (x) s) = true))
  lemma aux: forall x v s. (eval_disj_cnf v (DNeg_cnf (LVar x)) || eval_set v s) = eval_set v (add (PLCVar x) s)
  lemma aux1: forall v s. (eval_disj_cnf v (DNeg_cnf (LBottom)) || eval_set v s) = eval_set v (add (PLCBottom) s)
  lemma aux2: forall v s. eval_set v s = not(eval_conjunction_set v s)
  
  lemma elAbs1: forall v s. eval_set v (add (PLCBottom) s) = true
  lemma elAbs2: forall v s x. (not (v x)) = true -> eval_set v (add (PLCVar x) s) = true
  lemma elNeu1: forall v s x. (not (v x)) = false -> eval_set v (add (PLCVar x) s) = eval_set v s
  lemma aux1: forall v s. (cardinal s = 1) -> eval_set v s = not(eval_conjunction_set v s)
  lemma aux3: forall b1 b2. let x = b1 || b2 in let y = not(b1) && not(b2) in x = not y
  lemma aux2: forall v s. not (is_empty s) -> eval_set v s = not(eval_conjunction_set v s)
  *)
           
  (* let rec lemma evalset (v: valuation) (s: fset positive) (x: positive)
    requires { not FS.mem x s }
    variant { FS.cardinal s }
    ensures { eval_set v (FS.add x s) = ((not eval_positive v x) || eval_set v s) }
  = if FS.cardinal s > 1 then
      let p = FS.pick s in
        evalset v (FS.remove p s) x *)
  
         
  
  (*lemma setmany: forall v p s. eval_positive v p /\ FS.cardinal s > 1 -> eval_set v (FS.add p s) = eval_set v s*)
  
  let rec lemma deMorgan (v: valuation) (s: fset positive)
    requires{ not is_empty s }
    ensures{ eval_set v s = not eval_conjunction_set v s }
    variant{ FS.cardinal s }
  = if FS.cardinal s > 1 then
      let x = FS.pick s in
        deMorgan v (FS.remove x s)
        
  lemma evalemptyset_aux:
    forall v s x. (is_empty s) -> eval_set v (FS.add x s) = ((not eval_positive v x) || eval_set v s)
        
  axiom evalset_aux:
    forall v s x. (not (is_empty s)) -> eval_set v (FS.add x s) = ((not eval_positive v x) || eval_set v s)
 
  (* 
  lemma elAbs1: forall v s. eval_set v (add (PLCBottom) s)
  lemma elAbs2: forall v s x. not eval_positive v x -> eval_set v (add x s)
  lemma elNeu1: forall v s x. eval_positive v x ->  eval_set v (add (x) s) = eval_set v s
  lemma aux2: forall v s. not (is_empty s) -> eval_set v s = not(eval_conjunction_set v s) 
  *)

end





module Hornify
  
  use option.Option, int.Int, bool.Bool, Types, Valuation, Lemmas
  
  exception MoreThanOnePositive
 
  (* Functions *)
  
  let convertLiteralToR (pl: pliteral) : (rightside)
    ensures{ forall v. eval_literal v pl = eval_rightside v result }
  = match pl with
      | LBottom -> RBottom
      | LVar x -> RVar x
    end
   
  let convertLiteralToPLC (pl: pliteral) : (positive)
    ensures{ forall v. eval_literal v pl = eval_positive v result }
  = match pl with
      | LBottom -> PLCBottom
      | LVar x -> PLCVar x
    end
    
  let addLiterals (pl: pliteral) (nl: pliteral) (s: set) (p: option rightside) : (rs: set, rp: option rightside)
  requires{ p = None }
  ensures{ (not is_empty rs) }
  ensures { forall v. (eval_literal v pl || (not (eval_literal v nl)) || eval_set v s || eval_optionrightside v p) = (eval_set v rs || eval_optionrightside v rp) }
  = match pl with
      | LBottom -> let rbottom = Some (RBottom) in
                    match nl with
                      | LBottom -> ((add (PLCBottom) s), rbottom)
                      | LVar x -> ((add (PLCVar x) s), rbottom)
                    end
      | LVar x -> let rvar = Some (RVar x) in
                    match nl with
                      | LBottom -> ((add (PLCBottom) s), rvar)
                      | LVar x -> ((add (PLCVar x) s), rvar)
                      
                    end
   end
    
  let processCombination (pl: pliteral) (nl: pliteral) (s: set) (p: option rightside) : (rs: set, rp: option rightside)
  raises{ MoreThanOnePositive }
  ensures{ (not is_empty rs) }
  ensures { forall v. (eval_literal v pl || not (eval_literal v nl) || eval_set v s || eval_optionrightside v p) = (eval_set v rs || eval_optionrightside v rp) }
  = match p with
      | None -> addLiterals pl nl s p
      | Some _ -> raise MoreThanOnePositive
    end
  
    
  let rec hornify_aux (phi: clause_cnf) (s: set) (p: option rightside) : (rs: set, rp: option rightside)
  requires{ exists x y. phi = DOr_cnf x y }
  ensures{ (not is_empty rs) }
  ensures{ forall v. eval_domain v phi s p = eval_codomain v rs rp }
  ensures{ forall v. eval_domain v phi s p = implb (eval_conjunction_set v rs) (eval_optionrightside v rp) }
  raises{ MoreThanOnePositive }
  variant{ phi }
  = match phi with
      | DOr_cnf (DLiteral _) (DLiteral _) -> raise MoreThanOnePositive
      | DOr_cnf (DLiteral pl) (DNeg_cnf nl) | DOr_cnf (DNeg_cnf nl) (DLiteral pl) -> (* OR of positive literal and negative literal *)
                              processCombination pl nl s p
      | DOr_cnf (DNeg_cnf nl1) (DNeg_cnf nl2) -> ((add (convertLiteralToPLC nl1) (add (convertLiteralToPLC nl2) s)), p)
      | DOr_cnf (DOr_cnf phi1 phi2) (DLiteral pl) | DOr_cnf (DLiteral pl) (DOr_cnf phi1 phi2) -> (* OR of binary or and positive literal *)
                              match p with
                                | None -> hornify_aux (DOr_cnf phi1 phi2) s (Some (convertLiteralToR pl))
                                | Some _ -> raise MoreThanOnePositive
                              end 
      | DOr_cnf (DOr_cnf phi1 phi2) (DNeg_cnf nl) | DOr_cnf (DNeg_cnf nl) (DOr_cnf phi1 phi2) -> (* Combination of binary or and negative literal *)
                             hornify_aux (DOr_cnf phi1 phi2) (add (convertLiteralToPLC nl) s) p
      | DOr_cnf phi1 phi2 -> let (s1,p1) = hornify_aux phi1 s p in
                              hornify_aux phi2 s1 p1
      | _ -> absurd        
    end
    
    
  let conjunction (s: set): leftside
  requires{not is_empty s}
  ensures{forall v. eval_conjunction_set v s = eval_leftside v result }
  = let rec build (s: set)
     requires{not is_empty s}
     ensures{forall v. eval_conjunction_set v s = eval_positive v result}
     variant{cardinal s}
     = if(is_empty s) then absurd else
       if((cardinal s) = 1) then (choose s) else
       PLCAnd (choose s) (build (remove (choose s) s)) in
    LPos (build s)
 
   
  let getPositive (p: option rightside) : rightside
  ensures{forall v. eval_optionrightside v p = eval_rightside v result}
  = match p with
      | None -> RBottom
      | Some x -> x
    end
  
  let getBasicHorn (phi: clause_cnf) : basichornclause
  ensures{ forall v. eval_disj_cnf v phi = eval_basichornclause v result }
  raises{ MoreThanOnePositive }
  = match phi with
      | DLiteral (LVar x) -> BImpl (LTop) (RVar x)
      | DLiteral (LBottom) -> BImpl (LTop) (RBottom)
      | DNeg_cnf (LVar x) -> BImpl (LPos (PLCVar x)) (RBottom)
      | DNeg_cnf (LBottom) -> BImpl (LTop) (RTop)
      | DOr_cnf _ _ -> let (s,p) = hornify_aux phi (empty ()) None in
                             BImpl (conjunction s) (getPositive p) 
    end

  let rec function hornify (phi: formula_cnf) : hornclause
  raises{ MoreThanOnePositive }
  ensures{forall v. eval_formula_cnf v phi = eval_hornclause v result}
  variant{ phi }
  = match phi with
      | FClause_cnf phi1 -> HBasic (getBasicHorn phi1)
      | FAnd_cnf phi1 phi2 -> HAnd (hornify phi1) (hornify phi2)
  end
  
  
end

module Hornify_CPS

  use option.Option, int.Int, bool.Bool, Types, Valuation, Lemmas, Hornify

  let rec hornify_cps (phi: formula_cnf) (k: hornclause -> 'a) : 'a
  ensures{result = k(hornify phi)}
  variant{ phi }
  = match phi with
      | FClause_cnf phi1 -> k (HBasic (BImpl LTop RTop))
      | FAnd_cnf phi1 phi2 -> hornify_cps phi1 (fun con -> hornify_cps phi2 (fun con1-> k (HAnd con con1)))
  end

end




