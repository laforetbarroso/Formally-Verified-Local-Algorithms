module TypeForm
  use booltheory.BoolImplementation

  type atomicformula =
    | ATop
    | ABot
    | AVar i

  function eval_atomicformula (phi: atomicformula) (f: i -> t) : t
  = match phi with
      | ATop -> top
      | ABot -> bot
      | AVar i -> f i
    end
end

module SetAppAF

  use TypeForm

  clone export set.SetApp with type elt = atomicformula
  
end


module Converts

  use TypeForm

  use import formula.ConjunctiveNormalForm as CNF
  use import formula.Horn as HornFormula
  use import list.Mem as ListMem
  use list.List, list.Append, list.Length

  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option

  let function convertRStoAF (phi: rightside) : atomicformula
    ensures {forall f. eval_rightside (assign_rightside phi f) = eval_atomicformula result f}
    ensures { match phi with
                RProp t -> if t = top then result = ATop else result = ABot
                | RVar x -> result = AVar x
              end}
  = match phi with
      | RProp t -> if t = top then ATop else ABot
      | RVar x -> AVar x
    end

  let function convertPLtoAF (phi: pliteral) : atomicformula
    ensures { forall f.  eval_pliteral phi f = eval_atomicformula result f}
    ensures{ match phi with
              | LBottom -> result = ABot
              | LVar x -> result = AVar x
            end }
  = match phi with
      | LBottom -> ABot
      | LVar x -> AVar x
    end

  let function convertAFtoPL (phi: atomicformula) : pliteral
    requires{ phi <> ATop }
    ensures { forall f. eval_atomicformula phi f = eval_pliteral result f}
    ensures{ match phi with
              | ATop -> false
              | ABot -> result = LBottom
              | AVar x -> result = LVar x
            end }
  = match phi with
      | ATop -> absurd
      | ABot -> LBottom
      | AVar x -> LVar x
    end


  let function convertAFtoRS (phi: atomicformula) : rightside
    ensures { forall f. eval_atomicformula phi f = eval_rightside (assign_rightside result f)}
    ensures { match phi with
                | ATop -> result = RProp top
                | ABot -> result = RProp bot
                | AVar x -> result = RVar x
              end }
  = match phi with
      | ATop -> RProp top
      | ABot -> RProp bot
      | AVar x -> RVar x
    end

  lemma convertPLtoAF_evaluation: forall f phi. eval_pliteral phi f = eval_atomicformula (convertPLtoAF phi) f

  lemma convertAFtoPL_evaluation: forall f phi. phi <> ATop -> eval_atomicformula phi f = eval_pliteral (convertAFtoPL phi) f

  lemma PLtoAF_AFtoPL: forall x. x <> ATop -> x = convertPLtoAF (convertAFtoPL x)
  
  lemma RStoAF_AFtoRS: forall x. x = convertRStoAF (convertAFtoRS x)
  
  lemma AFtoRS_RStoAF: forall x. x = convertAFtoRS (convertRStoAF x)


end

module Eval

  use TypeForm

  use import formula.ConjunctiveNormalForm as CNF
  use import formula.Horn as HornFormula
  use list.Mem as ListMem
  use list.List, list.Append, list.Length, list.HdTl, list.Permut, list.NumOcc, list.Distinct

  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option
  use Converts
  use import set.Fset as FS
  
  (* EVALS*)
  
  (* (PROVED) EVAL OF SET OF CONJUNCTION *)

  function eval_setconjunction (s: fset atomicformula) (f: i-> BoolImplementation.t) : BoolImplementation.t

  axiom eval_setconjunction_empty: forall f, s: fset atomicformula. is_empty s -> eval_setconjunction s f = top

  axiom eval_setconjunction_pick: forall f, s: fset atomicformula. not is_empty s -> forall x. mem x s ->
        eval_setconjunction s f = (eval_atomicformula x f) /*\ eval_setconjunction (remove x s) f

  lemma eval_setconjunction_singleton: forall f, s: fset atomicformula. cardinal s = 1 ->
      let x = pick s in eval_setconjunction s f = (eval_atomicformula x f)

  
  (* EQ BETWEEN ATOMICFORMULA *)

  val function eq_pos (x y: atomicformula) : bool
    ensures { result <-> x = y }
    
  (* EQ BETWEEN RIGHTSIDE *)

  val function rs_eq_pos (x y: rightside) : bool
    ensures { result <-> x = y }
    
  (* (PROVED) EVAL COMMUTES WITH ADD *)

  let rec lemma eval_commutes_add (s: fset atomicformula) (x: atomicformula) (f: i -> t)
    variant { cardinal (add x s) }
    ensures { eval_setconjunction (add x s) f = eval_atomicformula x f /*\ eval_setconjunction s f }
  = if FS.is_empty s then ()
    else let y = FS.pick (FS.add x s) in
      if eq_pos x y then ()
      else let new_s = FS.remove y (FS.add x s) in
        eval_commutes_add new_s x f
        
        
  (* (PROVED) ADD EVAL *)

  lemma add_eval: forall f s x.
    eval_setconjunction (add x s) f = eval_atomicformula x f /*\ eval_setconjunction s f
    

  (* EVALUATE CLAUSE *)

  function eval_clause (clause: (fset atomicformula, rightside)) (f: i-> BoolImplementation.t) : BoolImplementation.t
  = match clause with
    | (setc,p) -> ((eval_setconjunction setc f) ->* (eval_rightside (assign_rightside p f)))
    end
    
  (* EVALUATE CLAUSELIST *)

  function eval_clauselist (l: list (fset atomicformula, rightside)) (f: i-> BoolImplementation.t) : BoolImplementation.t
  = match l with
      | Nil -> top
      | Cons clause l1 -> eval_clause clause f /*\ eval_clauselist l1 f
    end
    
    
  (*
    SATISFIABILITY
  *)
  
end

module SAT
  
  use TypeForm

  use import formula.ConjunctiveNormalForm as CNF
  use import formula.Horn as HornFormula
  use list.Mem as ListMem
  use list.List, list.Append, list.Length, list.HdTl, list.Permut, list.NumOcc, list.Distinct

  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option
  use Converts
  use import set.Fset as FS
  use Eval
 
  
  (* (PROVED) SATISFIABILITY LEMMAS *)
  
  predicate is_satisfiable_rs (rs: rightside)
  = exists f. eval_rightside (assign_rightside rs f) = top
  
  predicate is_unsatisfiable_rs (rs: rightside)
  = forall f. eval_rightside (assign_rightside rs f) = bot
  
  lemma rs_unsat_then_not_sat: 
    forall rs. is_unsatisfiable_rs rs ->
      not is_satisfiable_rs rs
  
  predicate is_satisfiable_af (af: atomicformula)
  = exists f. eval_atomicformula af f = top
  
  predicate is_unsatisfiable_af (af: atomicformula)
  = forall f. eval_atomicformula af f = bot
  
  lemma af_unsat_then_not_sat: 
    forall af. is_unsatisfiable_af af ->
      not is_satisfiable_af af
      
  predicate is_satisfiable_set (set: fset atomicformula)
  = exists f. eval_setconjunction set f = top
  
  predicate is_unsatisfiable_set (set: fset atomicformula)
  = forall f. eval_setconjunction set f = bot
  
  lemma set_unsat_then_not_sat: 
    forall set. is_unsatisfiable_set set ->
      not is_satisfiable_set set
  
  predicate is_satisfiable_clause (clause: (fset atomicformula, rightside))
  = exists f. eval_clause clause f = top
  
  predicate is_unsatisfiable_clause (clause: (fset atomicformula, rightside))
  = forall f. eval_clause clause f = bot
  
  lemma clause_unsat_then_not_sat: 
    forall clause. is_unsatisfiable_clause clause ->
      not is_satisfiable_clause clause
  
  predicate is_satisfiable_clauselist (clauselist: list (fset atomicformula, rightside))
  = exists f. eval_clauselist clauselist f = top
  
  predicate is_unsatisfiable_clauselist (clauselist: list (fset atomicformula, rightside))
  = forall f. eval_clauselist clauselist f = bot
  
  lemma cl_unsat_then_not_sat: forall cl. is_unsatisfiable_clauselist cl ->
                                  not is_satisfiable_clauselist cl
    
  constant val_all_top: i -> t = fun _ -> top
                                      
                                               
  let rec lemma all_set_without_bot_eval_set (c: fset atomicformula)
   requires{ not mem ABot c }
   ensures { (eval_setconjunction c val_all_top = top) }
   variant{ cardinal c }
  = if (FS.is_empty c) then
      ()
    else
      let o = pick c in
        all_set_without_bot_eval_set (FS.remove o c)
  
  
  let rec lemma bot_not_in_set_then_sat_set (c: fset atomicformula)
   requires{ not mem ABot c }
   ensures { exists f. eval_setconjunction c f = top }
   variant{ cardinal c }
  = if (FS.is_empty c) then
      ()
    else
      let o = pick c in
        bot_not_in_set_then_sat_set (FS.remove o c)
  
end

module Hornify

  use TypeForm

  use import formula.ConjunctiveNormalForm as CNF
  use import formula.Horn as HornFormula
  use list.Mem as ListMem
  use list.List, list.Append, list.Length, list.HdTl, list.Permut, list.NumOcc, list.Distinct

  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option
  use Converts
  use import set.Fset as FS
  use SetAppAF
  use Eval
  use SAT

  (*

    CONVERTING DATA STRUCTURES

  *)


  (* (PROVED) LEMMAS *)

  let rec lemma eval_union (s1: set) (s2: set) (f: i -> t)
   variant { cardinal s1 + cardinal s2 }
   ensures { eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f }
  = match is_empty s1, is_empty s2 with
    | True, True -> ()
    | False, True -> ()
    | True, False -> ()
    | False, False -> let element = choose s1 in eval_union (remove element s1) s2 f;
    assert { union s1 s2 == add element (union (remove element s1) s2) };
    assert { eval_setconjunction s1 f = eval_atomicformula element f /*\ eval_setconjunction (remove element s1) f }
   end

  lemma union_eval_empty: forall s1 s2 f. s1 = empty /\ s2 = empty -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f

  lemma union_eval_samesingleton: forall s1 s2 e f. s1 = singleton e /\ s2 = singleton e -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f

  lemma union_eval_diffsingleton: forall s1 s2 e1 e2 f. e1 <> e2 /\ s1 = singleton e1 /\ s2 = singleton e2 -> eval_setconjunction (union s1 s2) f = eval_setconjunction s1 f /*\ eval_setconjunction s2 f

  lemma add_then_mem_convertPLtoAF: forall x ns. ns = add (convertPLtoAF x) empty -> mem (convertPLtoAF x) ns


  (* CONVERT FUNCTIONS *)
  
  (* NUMBER OF HBASIC CONSTRUCTORS *)

  function numberOfHBasic (phi: hornclause) : int
  = match phi with
      | HBasic _ -> 1
      | HAnd e1 e2 -> numberOfHBasic e1 + numberOfHBasic e2
     end
     
  (* EXISTS X IN CONJ_PLITERAL? *)

  predicate op_and (x: pliteral) (phi: conj_pliteral)
  = match phi with
    | CPL y -> y = x
    | CPAnd w z -> op_and x w \/ op_and x z
   end

  (* CONVERT CONJ_PLITERAL IN SET *)

  let rec function convertConjunctionToSet (phi: conj_pliteral) : set
  = match phi with
      | CPL pl -> singleton (convertPLtoAF pl)
      | CPAnd c1 c2 -> union (convertConjunctionToSet c1) (convertConjunctionToSet c2)
    end

  (* (PROVED) Y EXISTS IN CONJ_PLITERAL -> Y IS IN CONVERT *)

  let rec lemma convertConjunctionToSet_lemma (y: pliteral) (phi: conj_pliteral)
    ensures { op_and y phi -> (mem (convertPLtoAF y) (convertConjunctionToSet phi)) }
  = match phi with
      | CPL _ -> ()
      | CPAnd c1 c2 -> convertConjunctionToSet_lemma y c1; convertConjunctionToSet_lemma y c2
     end
     
  (* (PROVED) Y IS IN CONVERT -> Y EXISTS IN CONJ_PLITERAL *)

  let rec lemma convertConjunctionToSet_lemma1 (y: atomicformula) (phi: conj_pliteral)
    ensures { mem y (convertConjunctionToSet phi) -> op_and (convertAFtoPL y) phi }
  = match phi with
      | CPL _ -> ()
      | CPAnd c1 c2 -> convertConjunctionToSet_lemma1 y c1; convertConjunctionToSet_lemma1 y c2
     end
     
  (* (PROVED) EVERY CONVERTCONJUNCTIONTOSET <> SINGLETON_ATOP *)
     
  let rec lemma convertConjunctionToSet_lemma_differs_singleton_atop (y: atomicformula) (phi: conj_pliteral)
    ensures { (convertConjunctionToSet phi) <> singleton ATop }
  = match phi with
      | CPL _ -> ()
      | CPAnd c1 c2 -> convertConjunctionToSet_lemma_differs_singleton_atop y c1; convertConjunctionToSet_lemma_differs_singleton_atop y c2
     end
     
  (* (PROVED) EVERY CONVERTCONJUNCTIONTOSET -> NOT SUBSET SINGLETON_ATOP *)  
   
  let rec lemma convertConjunctionToSet_lemma_subset (y: atomicformula) (phi: conj_pliteral)
    ensures { not subset (convertConjunctionToSet phi) (singleton ATop) }
  = match phi with
      | CPL _ -> ()
      | CPAnd c1 c2 -> convertConjunctionToSet_lemma_subset y c1; convertConjunctionToSet_lemma_subset y c2
     end
     
  (* (PROVED) EVAL SETCONJUNCTION OF CONVERT = EVAL_POSITIVE FORMULA *) 

  let rec lemma eval_equivalent (phi: conj_pliteral) (f: i -> t)
    variant { phi }
    ensures { let s = convertConjunctionToSet phi in HornFormula.eval_positive phi f = eval_setconjunction s f }
  = match phi with
      | CPL _ -> ()
      | CPAnd z w -> eval_equivalent z f; eval_equivalent w f
     end

  (* (PROVED) CONVERTTOSET FROM LEFTSIDE TO SET *) 

  let rec function convertToSet (phi: leftside) : set
    ensures{ phi = LTop -> result = singleton ATop }
    ensures{ forall c. phi = LPos c -> result = convertConjunctionToSet c }
  = match phi with
      | LTop -> singleton ATop
      | LPos c -> convertConjunctionToSet c
    end


  (* (PROVED) CONVERTTOLIST: FROM HORNCLAUSE TO LIST (SET,RIGHTSIDE)  *) 

  let rec function convertToList (phi: hornclause) : list (set, rightside)
    ensures{ forall l r. phi = HBasic (BImpl l r) -> ListMem.mem (convertToSet l, r) result }
    ensures{ length result = numberOfHBasic phi }
    ensures { result <> Nil }
  = match phi with
      | HBasic (BImpl l r) -> Cons ((convertToSet l), r) Nil
      | HAnd e1 e2 -> (convertToList e1) ++ (convertToList e2)
    end

end

module Horn_Logic

  use TypeForm
  use Eval
  use import formula.ConjunctiveNormalForm as CNF
  use import formula.Horn as HornFormula
  use list.Mem as ListMem
  use list.List, list.Append, list.Length, list.HdTl, list.Permut, list.NumOcc, list.Distinct

  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option
  use Converts
  use import set.Fset as FS
  use SAT
  
  (*

    HORN ALGORITHM STARTS HERE

  *)
  
  
  (* LIST(SET,RS) TO LIST(FSET ATOMICFORMULA,RS) *) 

  
   
  (*lemma to_fset_same_elem:
    forall x1 x2.
      to_fset x1 = to_fset x2 -> mk (to_fset x1) = mk (to_fset x2)
    
  lemma listset_to_listfset:
    forall cl1: list (set,rightside), x.
       is_nil cl1 = is_nil (listset_to_listfset cl1) /\ 
        ( let (s,r) = x in
            ListMem.mem (s,r) cl1 -> ListMem.mem ((to_fset s),r) (listset_to_listfset cl1) ) /\
              ( let (s,r) = x in
                  ListMem.mem ((to_fset s),r) (listset_to_listfset cl1) -> ListMem.mem (mk (to_fset s),r) cl1 ) 
*)
  (* NOTSUBSET: CHECKS IF A SPECIFIC SET IS NOT A SUBSET OF SOME CLAUSE *) 

 
     
  (* NOTSUBSET (LOGIC): CHECKS IF A SPECIFIC SET IS NOT A SUBSET OF SOME CLAUSE *) 
     
  predicate not_subset_spec (clauselist: list (fset atomicformula,rightside))
                                    (c: fset atomicformula)
  = match clauselist with
      | Nil -> true
      | Cons (setc,_) l -> (not subset setc c) /\
                              not_subset_spec l c
    end

  (* IF EXISTS SUBSET THEN RS IS IN RESULT *) 

  predicate if_subset_then_mem_result_clause (clause: (fset atomicformula,rightside))
                                             (c c': fset atomicformula)
  = let (setc, p) = clause in
      if( subset setc c ) then
        mem (convertRStoAF p) c'
      else c' = c


  (* IF RIGHT IN FINDFIRST THEN RS IS IN RESULT *) 

  predicate if_subset_then_mem_result (right: list (fset atomicformula,rightside))
                                      (c c': fset atomicformula)
  = match right with
    | Nil -> c' = c
    | Cons (setc,p) _ ->  if( subset setc c ) then
                            mem (convertRStoAF p) c'
                          else
                            false

    end
    
  (* (PROVED) DISTRIBUTION OF LISTSET_TO_LISTFSET *) 

  
      
  (* FIND FIRST SUBSET (LOGIC) *) 
  
  
  
  
  
    function removeFromList (elem: 'a) (clauselist: list 'a) : list 'a
  = match clauselist with
    | Nil -> Nil
    | Cons x l -> if (x = elem) then l else Cons x (removeFromList elem l)
    end
    
  lemma removeFromList_numocc:
    forall clauselist:list 'a, elem. ListMem.mem elem clauselist ->
      num_occ elem clauselist = 1 + num_occ elem (removeFromList elem clauselist)
      
  lemma removeFromList_numocc_2:
    forall clauselist:list 'a, elem x. ListMem.mem elem clauselist -> 
      not x = elem ->
        num_occ x clauselist = num_occ x (removeFromList elem clauselist)
    
  lemma removeFromList_length:
    forall clauselist:list 'a, elem. ListMem.mem elem clauselist ->
      length clauselist = 1 + length (removeFromList elem clauselist)

  

  
  
    
  
  function findOneSubset (clauselist: list (fset atomicformula,rightside)) 
                         (c: fset atomicformula) 
                         : option (fset atomicformula,rightside)
                         
  axiom findOneSubset_def: 
    forall cl c.
      match findOneSubset cl c with
        | None -> forall s p. (ListMem.mem (s,p) cl -> not subset s c)
        | Some (s,p) -> ListMem.mem (s,p) cl /\ subset s c 
      end
      
  axiom findOneSubset_exists:
     forall cl c.
      not is_nil cl ->
        (forall s1 p1. ListMem.mem (s1,p1) cl /\ subset s1 c ->
          findOneSubset cl c = Some (s1,p1))
          
  lemma findOneSubset_if_only_if_some:
     forall cl c.
      not is_nil cl ->
        (forall s1 p1. ListMem.mem (s1,p1) cl /\ subset s1 c <->
          findOneSubset cl c = Some (s1,p1))
        
          
  lemma findOneSubset_mem_subset:
    forall cl c.
      not is_nil cl ->
         match findOneSubset cl c with
        | None -> true
        | Some (s,p) -> ListMem.mem (s,p) cl /\ subset s c
      end
          
  lemma findOneSubset_nil:
    forall cl c.
      is_nil cl -> findOneSubset cl c = None
      
  lemma findOneSubset_notsubset:
    forall cl c.
      (forall s1 p1. (ListMem.mem (s1,p1) cl -> not subset s1 c)) -> 
        findOneSubset cl c = None
          
  goal G: false
  
  
  
          
          
          
    (*
    SET OF SYMBOLS OF CLAUSELIST
  
  *)    
      
  
  (* SET OF SYMBOLS OF CLAUSELIST *) 
  
  function set_smb_clauselist (clauselist: list (fset atomicformula,rightside)) : fset atomicformula
  = match clauselist with 
    | Nil -> empty
    | Cons (set,p) l -> union (add (convertRStoAF p) set) (set_smb_clauselist l)
    end
    
  (* (PROVED) IF MEM CLAUSELIST -> SET IS SUBSET OF SET_SMB_CLAUSELIST AND P MEM SET *) 
    
  lemma if_mem_then_subset_set_smb: forall set p clauselist.
    ListMem.mem (set,p) clauselist -> subset (add (convertRStoAF p) set) (set_smb_clauselist clauselist)
    
  (* (PROVED) IF MEM CLAUSELIST -> P MEM SET *)  

  lemma subset_set_smb_clauselist:
    forall clauselist set p.
      ListMem.mem (set,p) clauselist -> mem (convertRStoAF p) (set_smb_clauselist clauselist)
  
  (* (PROVED) SUBLIST: SUBSET (SET_SMB SUBLIST) (SET_SMB LIST) *)  
    
  lemma sublist_subset_set_smb:
    forall clauselist sublist. (forall clause.
      (ListMem.mem clause sublist -> ListMem.mem clause clauselist)) -> 
        subset (set_smb_clauselist sublist) (set_smb_clauselist clauselist)  
  
  let rec ghost function algorithmA_spec (clauselist: list (fset atomicformula,rightside))
                              (c: fset atomicformula) : fset atomicformula
    requires{ mem ATop c }
    requires{ not mem ABot c }
    ensures { subset c result }
    ensures { subset (diff result c) (add ATop (add ABot (set_smb_clauselist clauselist))) }
    variant { length clauselist }
  = match clauselist with
    | Nil -> c
    | Cons _ _ -> match findOneSubset clauselist c with
                  | None -> c
                  | Some (s,p) -> if eq_pos (convertRStoAF p) ABot then
                                    (FS.add ABot c)
                                  else
                                    algorithmA_spec (removeFromList (s,p) clauselist) (FS.add (convertRStoAF p) c)
                  end
    end
   
   
  let rec lemma permutacoes (clauselist clauselist2: list (fset atomicformula, rightside)) (c: fset atomicformula)
    requires { permut clauselist clauselist2 }
    requires { mem ATop c }
    requires{ not mem ABot c }
    ensures { (algorithmA_spec clauselist c == algorithmA_spec clauselist2 c) }
    variant { length clauselist }
    = match clauselist with
    | Nil -> c
    | Cons _ _ -> match findOneSubset clauselist c with
                  | None -> c
                  | Some (s,p) -> if eq_pos (convertRStoAF p) ABot then
                                    (FS.add ABot c)
                                  else
                                    permutacoes (removeFromList (s,p) clauselist) (removeFromList (s,p) clauselist2) (FS.add (convertRStoAF p) c)

                  end
    end
    
  let rec lemma monotone_algA (c d: fset atomicformula) (clauselist: list (fset atomicformula,rightside))
    requires { mem ATop c }
    requires{ not mem ABot c }
    requires{ not mem ABot d }
    requires { subset c d }
    ensures { subset (algorithmA_spec clauselist c) (algorithmA_spec clauselist d)  }
    variant { length clauselist }
  = match clauselist with
    | Nil -> ()
    | _ ->  match findOneSubset clauselist c with
                  | None -> ()
                  | Some (s,p) -> if eq_pos (convertRStoAF p) ABot then
                                    ()
                                  else
                                    monotone_algA (FS.add (convertRStoAF p) c) (FS.add (convertRStoAF p) d) (removeFromList (s,p) clauselist)
                  end
    end
    
    
    
    
    
    
    
     
        
        
  (* PROVED UNTIL HERE *)
  
  
  let rec lemma all_x_top_then_eval_setconjunction_top (s: fset atomicformula) (f: i -> t)
    ensures  { (forall x. mem x s -> 
      eval_atomicformula x f = top) -> 
        eval_setconjunction s f = top }
    variant{ cardinal s }
  = if( FS.is_empty s ) then
      ()
    else
      let o = pick s in
        all_x_top_then_eval_setconjunction_top (FS.remove o s) f
  
  
  lemma subset_of_evalsetconjunction_1:
    forall c d.
      subset c d -> 
        (exists f:(i -> t). (not eval_setconjunction d f = top \/ eval_setconjunction c f = top))
        
  
  lemma subset_of_evalsetconjunction:
    forall c d.
      subset c d -> 
        (exists f:i -> t. eval_setconjunction d f = top) -> 
          (exists g:i -> t. eval_setconjunction c g = top)
          
  lemma contr_exists:
      (forall c d.
        subset c d -> 
          (exists f:i -> t. eval_setconjunction d f = top) -> 
            (exists g:i -> t. eval_setconjunction c g = top)) ->
       (forall c d.
        subset c d -> 
          (exists f:i -> t. not eval_setconjunction d f = top \/ eval_setconjunction c f = top))
          
  lemma distr_exists:
      (forall c d.
        subset c d -> 
          (exists f:i -> t. (not eval_setconjunction d f = top \/ eval_setconjunction c f = top))) -> 
        (forall c d.
      subset c d -> 
        (exists f:i -> t. eval_setconjunction d f = top) -> 
          (exists g:i -> t. eval_setconjunction c g = top))
          
        
  lemma subset_of_satisfiable_set:
    forall c d f.
      ((eval_setconjunction d f = top) /\ subset c d) -> (eval_setconjunction c f = top)
      
  
  
 
      
      
  lemma sublist_is_satisfiable_clauselist:
    forall clauselist sublist. (forall clause.
      (ListMem.mem clause sublist -> ListMem.mem clause clauselist)) ->
        (is_satisfiable_clauselist clauselist -> is_satisfiable_clauselist sublist)
     
       
                 
  (* SMB LEMMAS (PROVED) *)
  
  
  lemma smb_generic: forall clauselist newc c. 
      mem ATop c /\ not mem ABot c /\ 
        subset c (add (ATop) (add ABot (set_smb_clauselist clauselist))) ->
          newc = algorithmA_spec clauselist c ->
            subset newc (add (ATop) (add ABot (set_smb_clauselist clauselist)))    
   
  lemma smb: forall clauselist c. 
        c = algorithmA_spec clauselist (singleton ATop) ->
          subset c (add (ATop) (add ABot (set_smb_clauselist clauselist)))
          
  (* END OF SMB LEMMAS (PROVED) *)
  
  
  (* START OF MONOTONE LEMMAS *)
  
  lemma not_subset_spec_test: forall l c. not_subset_spec l c -> (forall set p. ListMem.mem (set,p) l -> not subset set c)
  
  (*let rec lemma algorithmA_aux (c set: fset atomicformula) (clauselist left right l: list (fset atomicformula,rightside)) (p: rightside)
    requires { mem ATop c }
    requires { subset set c }
    requires { right = Cons (set,p) l }
    requires { clauselist = left ++ right }
    requires { let (l,r) = findFirst clauselist c in r <> Nil }
    ensures { algorithmA_spec clauselist c = algorithmA_spec (left ++ l) (add (convertRStoAF p) c) }
  = let (l,r) = findFirst clauselist c in
      ()*)
      
  predicate is_equal_list (list1 list2: list 'a)
  = match list1,list2 with
    | Nil, Nil -> True
    | Cons _ _, Nil | Nil, Cons _ _ -> False
    | Cons x1 list1', Cons x2 list2' -> 
        x1 = x2 && 
        is_equal_list list1' list2'
    end
    
  let rec lemma equality_is_equal_list (l1 l2: list 'a)
    requires { is_equal_list l1 l2 }
    ensures { l1 = l2 }
  = match l1,l2 with
    | Nil, Nil -> ()
    | Cons x l, Cons y ls -> begin assert { x = y } end; 
                              equality_is_equal_list l ls
    | _ -> ()
    end
    
  let rec lemma is_equal_list_reflexive (l1: list 'a)
    ensures { is_equal_list l1 l1 }
  = match l1 with
    | Nil -> ()
    | Cons x ls -> begin assert { x = x } end; 
                    is_equal_list_reflexive ls
    end
    
    
  let rec lemma is_equal_list_commutative (l1 l2: list 'a)
    ensures { is_equal_list l1 l2 <-> is_equal_list l2 l1 }
  = ()
    
    

      
      
  let rec lemma tuple_equality (z1 z2 r1 r2: list 'a)
    ensures { is_equal_list (z1++z2) (r1++r2) -> is_equal_list z1 r1 -> is_equal_list z2 r2 }
    ensures { is_equal_list (z1++z2) (r1++r2) -> is_equal_list z2 r2 -> is_equal_list z1 r1 }
    variant { length r1 }
  = match z1,r1 with
    | Nil, Nil -> ()
    | Cons _ l, Cons _ lx -> tuple_equality l z2 lx r2
    | _ -> ()
    end
    
  lemma permut_ref:
    forall cl: list 'a.
      permut cl cl
  
  lemma permut_trans:
    forall cl1 cl2 cl3: list 'a.
      permut cl1 cl2 && permut cl2 cl3 -> permut cl1 cl3
  

  
  
  let lemma num_occ_permut_concat (left right left1 right1: list (fset atomicformula, rightside))
    requires { permut (left ++ right) (left1 ++ right1) }
    ensures { forall x. num_occ x (left ++ right) = num_occ x (left1 ++ right1) }
  = ()
  
  let lemma num_occ_concat (left right: list (fset atomicformula, rightside))
    ensures { forall x. num_occ x (left ++ right)  = num_occ x left + num_occ x right }
  = ()
  
  let lemma num_occ_1_plus_tail (set: fset atomicformula) (p: rightside) (left right l: list (fset atomicformula, rightside))
    requires { is_equal_list right (Cons (set,p) l) }
    ensures { 1 + num_occ (set,p) (left ++ l) = num_occ (set,p) (left ++ right) }
  = begin
      assert { num_occ (set,p) right = 1 + num_occ (set,p) l }
    end
  
  let lemma num_occ_permut_list (set: fset atomicformula) (p: rightside) (left right l left1 right1 l1: list (fset atomicformula, rightside))
    requires { permut (left ++ right) (left1 ++ right1) }
    requires { is_equal_list right (Cons (set,p) l) }
    requires { is_equal_list right1 (Cons (set,p) l1) }
    ensures { forall x. num_occ x (left ++ l) = num_occ x (left1 ++ l1) }
  = ()
  
  let lemma permut_list_permut_sublist (set: fset atomicformula) (p: rightside) (left right l left1 right1 l1: list (fset atomicformula, rightside))
    requires { permut (left ++ right) (left1 ++ right1) }
    requires { is_equal_list right (Cons (set,p) l) }
    requires { is_equal_list right1 (Cons (set,p) l1) }
    ensures { permut (left ++ l) (left1 ++ l1) }
  =  begin 
        assert{num_occ (set,p) right = 1 + num_occ (set,p) l};
     end
     
  lemma permut_cl1_cl2:
      forall cl1 cl2: list 'a.
        permut cl1 cl2 <->
          permut cl2 cl1
          
          
          
  lemma concat_with_element: 
    forall l:list 'a, x.
      ListMem.mem x l ->
        exists l1 l2. is_equal_list (l1 ++ (Cons x l2)) l
            
  lemma removeFromList_concat_not_mem_l1:
     forall l1 l2:list 'a, x.
        not ListMem.mem x l1 ->
          is_equal_list (removeFromList x (l1 ++ l2)) (l1 ++ (removeFromList x l2))
          
  lemma removeFromList_concat:
    forall left l1 l2: list 'a, x.
        not ListMem.mem x left ->
          is_equal_list (left ++ (Cons x l1)) l2 ->
            is_equal_list (removeFromList x l2) (left ++ l1)
            
    lemma removeFromList_permut:
    forall clauselist clauselist2:list 'a, elem. ListMem.mem elem clauselist ->
      permut clauselist clauselist2 -> 
        permut (removeFromList elem clauselist) (removeFromList elem clauselist2)
        
  lemma removeFromList_permut_concat:
    forall left right l clauselist2:list 'a, x.
      is_equal_list right (Cons x l) ->
        permut (left ++ right) clauselist2 ->
          permut (left ++ l) (removeFromList x clauselist2)
  
  lemma removeFromList_elem_not_in_list:
    forall l:list 'a, x.
      not ListMem.mem x l ->
        is_equal_list (removeFromList x l) l
          
          
  let rec ghost function numOfSubset (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula)
    variant { length clauselist }
    ensures { result >= 0 /\ result <= length clauselist }
    ensures { result > 0 -> exists set p. ListMem.mem (set,p) clauselist /\ subset set c }
  = match clauselist with
    | Nil -> 0
    | Cons (set,_) l ->
        if (FS.subset set c) then
          1 + numOfSubset l c
        else
          numOfSubset l c
    end
    
 
  
  lemma not_subset_spec_for_all:
    forall set:fset 'a, clauselist c p.
      (ListMem.mem (set,p) clauselist ->
        not subset set (add p c)) ->
      (ListMem.mem (set,p) clauselist ->
        not subset set c)
  
  lemma not_subset_general:
    forall clauselist c.
      not_subset_spec clauselist c <-> 
        (forall x1 x2. ListMem.mem (x1,x2) clauselist -> not subset x1 c)
    
  lemma not_subset_numOfSubset_0:
    forall clauselist c.
      not_subset_spec clauselist c -> (numOfSubset clauselist c = 0)
      
  let rec lemma numOfSubset_0_not_subset (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula) 
    requires{ (numOfSubset clauselist c) = 0 }
    ensures { not_subset_spec clauselist c }
  = match clauselist with
    | Nil -> ()
    | Cons (set,_) l -> begin assert{ not subset set c } end;
      numOfSubset_0_not_subset l c
    end
    
  lemma notSubset_numOfSubset_0:
    forall clauselist c.
      ((numOfSubset clauselist c) = 0) ->
        (forall set p. ListMem.mem (set,p) clauselist -> not subset set c)
        
  lemma notSubset_numOfSubset_1:
    forall clauselist c.
      (numOfSubset clauselist c = 1) ->
        (exists set p. ListMem.mem (set,p) clauselist /\ subset set c)
        
  lemma addSubset_to_numOfSubset:
    forall clauselist c set p.
      (numOfSubset clauselist c = 0) ->
        subset set c ->
          (numOfSubset (Cons (set,p) clauselist) c = 1)
                
  lemma removeNumOfSubset:
    forall clauselist c set p.
      ListMem.mem (set,p) clauselist ->
        subset set c ->
          numOfSubset (removeFromList (set, p) clauselist) c = (numOfSubset clauselist c) - 1
    
  lemma numOfSubset_clauselist_c_1:
    forall clauselist c set p.
      ListMem.mem (set,p) clauselist ->
        subset set c ->
          num_occ (set, p) clauselist = 1 ->
            numOfSubset (removeFromList (set, p) clauselist) c = 0 ->
              numOfSubset clauselist c = 1
              
  lemma numOfSubset_1_num_occ:
    forall clauselist c set p.
      ListMem.mem (set,p) clauselist ->
        subset set c ->
          (numOfSubset clauselist c = 1) ->
            (num_occ (set,p) clauselist = 1)
            
            
  lemma numOfSubset_1:
    forall clauselist c set p.
      ListMem.mem (set,p) clauselist ->
        subset set c ->
          (numOfSubset clauselist c = 1) ->
            (forall set1 p1. (ListMem.mem (set1,p1) clauselist /\ subset set1 c) ->
              (set1,p1) = (set,p))
        
          
 
       
  
 
     
  let rec lemma not_subset_permut (clauselist clauselist2: list (fset atomicformula, rightside)) (c: fset atomicformula)
    requires { permut clauselist clauselist2}
    requires { not_subset_spec clauselist c }
    ensures { not_subset_spec clauselist2 c }
    variant { length clauselist }
  = match clauselist with
    | Nil -> ()
    | Cons x l -> not_subset_permut l (removeFromList x clauselist2) c
    end
    

          
  (* PERMUTATIONS CASE 2: ALGORITHMA CLAUSELIST C = AGLORITHMA (LEFT++L) (C U {p}) *)
    
  predicate notOccurs (s: fset atomicformula) (l: list (fset atomicformula, rightside))
  = match l with
    | Nil -> true
    | Cons (set,_) ls -> if ( set == s ) then false else notOccurs s ls
    end
  
  (* PERMUTATIONS CASE 2: ALGORITHMA CLAUSELIST C = AGLORITHMA (LEFT++L) (C U {p}) *)
  
  (*function remove_elt (e: 'a) (l: list 'a) : list 'a
  = match l with
    | Nil -> Nil
    | Cons x xs -> if e = x then 
                    (remove_elt e xs) 
                   else 
                    Cons x (remove_elt e xs)
   end
   
  lemma remove_elt_length: forall e:'a, l:list 'a.
    length (remove_elt e l) <= length l
    
  lemma remove_elt:
   forall e:'a, l.
    not ListMem.mem e (remove_elt e l)
    
  lemma remove_elt_all:
   forall e:'a, a:'a, l.
    ListMem.mem a (remove_elt e l) -> num_occ a (remove_elt e l) = num_occ a l
  
  let rec ghost function remove_duplicates (l: list 'a) : list 'a
    variant { length l }
    ensures { forall x. ListMem.mem x result -> num_occ x result = 1 } 
    ensures { forall x. ListMem.mem x l -> ListMem.mem x result }
  = match l with
    | Nil -> Nil
    | Cons x xs -> Cons x (remove_duplicates (remove_elt x xs))
  end
  
  function removeClauses_where_rightIsInC (l: list (fset atomicformula, rightside)) (c: fset atomicformula) : list (fset atomicformula, rightside)
  = match l with
    | Nil -> Nil
    | Cons (elem,x) xs -> if FS.mem (convertRStoAF x) c then 
                            (removeClauses_where_rightIsInC xs c) 
                          else 
                            Cons (elem,x) (removeClauses_where_rightIsInC xs c) 
    end
   
  
  lemma algorithmA_test: forall x xs1 elem xs2 c.
    is_equal_list x (Cons elem xs1) ->
    is_equal_list xs1 (Cons elem xs2) ->
      algorithmA_spec x c == algorithmA_spec xs1 c
      
  lemma add_to_set_mem:
    forall elem:'a, set.
      mem elem set ->
        add elem set == set
      
  lemma algorithmA_without_duplicates_1: forall cl c.
    forall s p.
      mem (convertRStoAF p) c -> 
        algorithmA_spec cl c == algorithmA_spec (remove_elt (s,p) cl) c 
  
  lemma algorithmA_withtout_duplicates: forall x c. 
      mem ATop c -> 
        algorithmA_spec x c == algorithmA_spec (remove_duplicates x) c
        
  lemma algorithmA_withtout_rightInC: forall x c. 
      mem ATop c -> 
        algorithmA_spec x c == algorithmA_spec (removeClauses_where_rightIsInC x c) c
  *)
  
  lemma set_equality_add: forall set:fset 'a,elem1 elem2. (add elem1 (add elem2 set)) == (add elem2 (add elem1 set))
  
  
  let lemma removeTwoClauses_basecase (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula) (elem1 elem2: (fset atomicformula, rightside))
    requires { mem ATop c }
    requires { not mem ABot c }
    requires { not elem1 = elem2 }
    requires { let (_,p1) = elem1 in
               let (_,p2) = elem2 in 
               (convertRStoAF p1) <> ABot /\ (convertRStoAF p2) <> ABot }
    requires { ListMem.mem elem1 clauselist }
    requires { ListMem.mem elem2 clauselist }
    requires { is_equal_list clauselist (Cons elem1 (Cons elem2 Nil)) }
    requires { let (s1,_) = elem1 in subset s1 c}
    requires { let (s2,_) = elem2 in subset s2 c}
    ensures { let (_,p1) = elem1 in
              let (_,p2) = elem2 in  
              algorithmA_spec (removeFromList elem1 clauselist) (FS.add (convertRStoAF p1) c)
              == algorithmA_spec (removeFromList elem2 clauselist) (FS.add (convertRStoAF p2) c) }
  = ()
  
  
  
  
  let lemma removeTwoClauses_inductive_case2 (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula) (elem1 elem2: (fset atomicformula, rightside))
    requires { mem ATop c }
    requires { not mem ABot c }
    requires { not elem1 = elem2 }
    requires { ListMem.mem elem1 clauselist }
    requires { ListMem.mem elem2 clauselist }
    requires { let (_,p1) = elem1 in
               let (_,p2) = elem2 in 
               (convertRStoAF p1) <> ABot /\ (convertRStoAF p2) <> ABot }
    requires { let (s1,_) = elem1 in subset s1 c}
    requires { let (s2,_) = elem2 in subset s2 c}
    ensures { let (_,p1) = elem1 in
              let (_,p2) = elem2 in  
              algorithmA_spec (removeFromList elem1 clauselist) (FS.add (convertRStoAF p1) c)
              == algorithmA_spec (removeFromList elem2 clauselist) (FS.add (convertRStoAF p2) c) }
  = ()
  
  
  let lemma removeTwoClauses (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula) (elem1 elem2: (fset atomicformula, rightside))
    requires { mem ATop c }
    requires { not mem ABot c }
    requires { ListMem.mem elem1 clauselist }
    requires { ListMem.mem elem2 clauselist }
    requires { let (_,p1) = elem1 in
               let (_,p2) = elem2 in 
               (convertRStoAF p1) <> ABot /\ (convertRStoAF p2) <> ABot }
    requires { let (s1,_) = elem1 in subset s1 c}
    requires { let (s2,_) = elem2 in subset s2 c}
    ensures { let (_,p1) = elem1 in
              let (_,p2) = elem2 in  
              algorithmA_spec (removeFromList elem1 clauselist) (FS.add (convertRStoAF p1) c)
              == algorithmA_spec (removeFromList elem2 clauselist) (FS.add (convertRStoAF p2) c) }
  = ()
  
  let lemma removeFromList_algorithmA (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula) (elem: (fset atomicformula, rightside))
    requires { mem ATop c }
    requires { not mem ABot c }
    requires { ListMem.mem elem clauselist }
    requires { let (set,_) = elem in subset set c}
    requires { let (_,p) = elem in 
               (convertRStoAF p) <> ABot }
    ensures { let (set,p) = elem in  
              algorithmA_spec clauselist c == 
              algorithmA_spec (removeFromList (set,p) clauselist) (FS.add (convertRStoAF p) c) }
  = ()

        
  (* END OF MONOTONE LEMMAS *)
      
  (* START OF HERBRAND LEMMAS *)
  
  lemma diff_is_sat_p:
    forall clauselist c. is_satisfiable_clauselist clauselist -> 
      (let result = algorithmA_spec clauselist c in
                not mem ABot result -> 
                  (forall p. mem p (diff result c) -> is_satisfiable_af p))
  
  lemma herbrand_model_case1: forall clause p.
    clause = (singleton ATop, p) /\ is_satisfiable_clause clause -> is_satisfiable_rs p
    
  lemma herbrand_model_case2: forall clause p setc.
    clause = (setc, p) /\ is_satisfiable_clause clause /\ p = RProp bot -> exists f. eval_setconjunction setc f = bot
               
  lemma herbrand_model_case3: forall clause p setc.
    clause = (setc, p) /\ is_satisfiable_clause clause /\ is_unsatisfiable_rs p -> exists f. eval_setconjunction setc f = bot
  
  (*lemma herbrand_model_case4: forall clause p setc.
    clause = (setc, p) /\ is_satisfiable_clause clause /\ is_satisfiable_set setc -> is_satisfiable_rs p
  *)
  lemma if_sat_clauselist_sat_clause: forall clauselist clause.
    is_satisfiable_clauselist clauselist /\ ListMem.mem clause clauselist -> is_satisfiable_clause clause
       
  lemma herbrand_model: forall c clauselist set.
       (is_satisfiable_clauselist clauselist /\ 
        mem ATop set /\ not mem ABot set /\
        (forall p. mem p set -> is_satisfiable_af p)) -> 
          c = algorithmA_spec clauselist set -> 
            not mem ABot c ->
              (forall p. mem p c -> is_satisfiable_af p)
              
  (* END OF HERBRAND LEMMAS *) 
        

   
  (*lemma is_sat_clause_sat_rs:
    forall set p.
      is_satisfiable_clause (set,p) -> is_satisfiable_set set -> is_satisfiable_rs p  
   *)

      
  lemma is_sat_set:
    forall clauselist c.
      is_satisfiable_set c -> 
      match findOneSubset clauselist c with
        | None -> true
        | Some (s,p) -> if is_unsatisfiable_clause (s,p) then
                          is_unsatisfiable_rs p
                        else
                          is_satisfiable_rs p
      end
      
      
      
  
    
  (* PROOF OF HORN ALGORITHM *)  
   
  predicate not_empty_setc_clauselist (clauselist: list (fset atomicformula, rightside))
  = match clauselist with
    | Nil -> true
    | Cons (setc,_) l -> not is_empty setc /\ not_empty_setc_clauselist l
    end
    
  lemma removeFromList_not_empty_setc_clauselist:
    forall x1 x clauselist.
      not_empty_setc_clauselist clauselist ->
        not_empty_setc_clauselist (removeFromList (x1, x) clauselist)
    
    
  (* 
  
    T -> P
    
    not mem BOT A(T->P, {T})
    
    (PROVED)
  
  *)
      
  lemma case1_top_imples_p: forall clauselist p.
    let clause = (singleton ATop,p) in
      clauselist = (Cons clause Nil) /\
        is_satisfiable_clause clause ->
          is_satisfiable_rs p /\
            not mem ABot
              (algorithmA_spec clauselist (singleton ATop))
              
  (* 
  
    SET -> P
    
    SET <> SINGLETON ATOP
    
    not mem BOT A(set -> P, {T})
    
    (PROVED)
  
  *)
  
  lemma case1_conjuction_imples_p: forall clauselist setc p.
    let clause = (setc,p) in
      setc <> (singleton ATop) /\
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            is_satisfiable_clause clause ->
                not mem ABot
                  (algorithmA_spec clauselist (singleton ATop))
                  
  
  (* 
  
    GENERAL CASE 1 CASE
    
    SET -> P
    
    not mem BOT A(set -> P, {T})
    
    (PROVED)
  
  *)
  
                  
  lemma case1_general: forall clauselist setc p.
    let clause = (setc,p) in
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            is_satisfiable_clause clause ->
                not mem ABot
                  (algorithmA_spec clauselist ((singleton ATop)))
                  
                  
  lemma case1_general_top_imples_p: forall clauselist setc p.
    ( let clause = (setc,p) in
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            is_satisfiable_clause clause ->
                not mem ABot
                  (algorithmA_spec clauselist ((singleton ATop))) ) -> (let clause = (singleton ATop,p) in
      clauselist = (Cons clause Nil) /\
        is_satisfiable_clause clause ->
          is_satisfiable_rs p /\
            not mem ABot
              (algorithmA_spec clauselist (singleton ATop)))
              
  lemma case1_general_conjuction_imples_p: forall clauselist setc p.
    ( let clause = (setc,p) in
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            is_satisfiable_clause clause ->
                not mem ABot
                  (algorithmA_spec clauselist ((singleton ATop))) ) -> (let clause = (setc,p) in
      setc <> (singleton ATop) /\
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            is_satisfiable_clause clause ->
                not mem ABot
                  (algorithmA_spec clauselist (singleton ATop)))
                  
  (* END OF CASE1 AND GENERAL CASE *)
  
  (*START OF CASE 2 *)
  
  
  (* 
    
    T -> P
    
    not mem BOT c
    
    not mem BOT A(T -> P, c)
    
    (PROVED)
  
  *)
                  
                  
  lemma case2_top_imples_p: forall clauselist p c.
    let clause = (singleton ATop,p) in
      clauselist = (Cons clause Nil) /\
        is_satisfiable_clause clause /\
          not mem ABot c /\ mem ATop c -> 
            is_satisfiable_rs p ->
                not mem ABot
                  (algorithmA_spec clauselist c)
                  
  (* 
    
    set -> P
    
    not mem BOT c
    
    not mem BOT A(set -> P, c)
    
    (NOT PROVED)
  
  *)
  
  lemma case2_conjunction_imples_p: forall clauselist setc p c.
    let clause = (setc,p) in
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            not mem ABot c /\ mem ATop c /\
             is_satisfiable_clauselist clauselist ->
                    not mem ABot
                      (algorithmA_spec clauselist c)
                  
  lemma case2_general: forall clauselist setc p c.
    let clause = (setc,p) in
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            not mem ABot c /\ mem ATop c /\
                is_satisfiable_clause clause ->
                    not mem ABot
                      (algorithmA_spec clauselist c)
                    
                   
  lemma case2_general_top_imples_p: forall clauselist setc p c.
    (let clause = (setc,p) in
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            not mem ABot c /\ mem ATop c /\
              is_satisfiable_clause clause ->
                    not mem ABot
                      (algorithmA_spec clauselist c)) -> (let clause = (singleton ATop,p) in
      clauselist = (Cons clause Nil) /\
        is_satisfiable_clause clause /\
          not mem ABot c /\ mem ATop c ->
              is_satisfiable_rs p ->
                not mem ABot
                  (algorithmA_spec clauselist c))
                  
  lemma case2_general_conjunction_imples_p: forall clauselist setc p c.
    (let clause = (setc,p) in
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            not mem ABot c /\ mem ATop c /\
              is_satisfiable_clause clause ->
                  not mem ABot
                    (algorithmA_spec clauselist c)) -> (let clause = (setc,p) in
        not is_empty setc /\
          clauselist = Cons clause Nil /\
            not mem ABot c /\ mem ATop c /\
              is_satisfiable_clauselist clauselist ->
                  not mem ABot
                    (algorithmA_spec clauselist c))
                    
                    
  (* END OF CASE 2 *)
  
  (* START OF INDUCTION CASE *)
  
  
  let rec lemma case3_induction_general (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula)
    requires { clauselist <> Nil }
    requires { is_satisfiable_clauselist clauselist }
    requires { not_empty_setc_clauselist clauselist }
    requires { not mem ABot c }
    requires { mem ATop c }
    requires { is_satisfiable_set c }
    ensures { not mem ABot (algorithmA_spec clauselist c) }
    variant { length clauselist }
  = match clauselist with
    | Cons _ Nil -> ()
    | Cons _ _ -> match findOneSubset clauselist c with
                  | None -> ()
                  | Some (s,p) -> if eq_pos (convertRStoAF p) ABot then
                                    ()
                                  else
                                    case3_induction_general (removeFromList (s,p) clauselist) (FS.add (convertRStoAF p) c)
                  end      
    | _ -> absurd
    end           
                  
  lemma case3_induction: forall clauselist.
    clauselist <> Nil /\
      is_satisfiable_clauselist clauselist /\
        not_empty_setc_clauselist clauselist ->
          not mem ABot
               (algorithmA_spec clauselist (singleton ATop))
               
  goal G1: false
               
  (*let rec lemma unsat_induction_general (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula)
    requires { clauselist <> Nil }
    requires { is_unsatisfiable_clauselist clauselist }
    requires { not_empty_setc_clauselist clauselist }
    requires { mem ATop c }
    ensures { mem ABot (algorithmA_spec clauselist c) }
    variant { length clauselist }
  = match clauselist with
    | Cons _ Nil -> ()
    | Cons _ _ -> match findOneSubset clauselist c with
                  | None -> ()
                  | Some (s,p) -> unsat_induction_general (removeFromList (s,p) clauselist) (FS.add (convertRStoAF p) c)
                  end
    end*)
    
  lemma unsat_then_bot:
    forall p. 
      (forall f:i -> t. eval_rightside (assign_rightside p f) = bot) -> rs_eq_pos p (RProp bot)
    
  lemma is_unsat_then_p_is_bot:
    forall x p.
      is_unsatisfiable_clause (x,p) -> rs_eq_pos p (RProp bot)
      
  
  (*lemma is_sat_set_then_subset:
    forall x p cl c.
      is_satisfiable_set x /\ ListMem.mem (x,p) cl /\ mem ATop c /\ not mem ABot c -> 
        subset x (algorithmA_spec cl c)  
      
  
  lemma is_unsat_then_subset_singletonATop:
    forall x p cl.
      is_unsatisfiable_clause (x,p) /\ ListMem.mem (x,p) cl -> 
        subset x (algorithmA_spec cl (singleton ATop))    
  
  lemma is_unsat_then_subset:
    forall x p cl c.
      is_unsatisfiable_clause (x,p) /\ ListMem.mem (x,p) cl /\ mem ATop c /\ not mem ABot c -> 
        subset x (algorithmA_spec cl c)*)
        
  lemma unsat_clauselist_then_exists_one_clause_unsat:
    forall clauselist. 
      is_unsatisfiable_clauselist clauselist <->
        exists x p. is_unsatisfiable_clause (x,p) /\ ListMem.mem (x,p) clauselist
                    
                    
  (* END OF CASE 2 *)
  
  (* START OF INDUCTION CASE *)     
                      
  
  let rec lemma unsat_induction_general (clauselist: list (fset atomicformula, rightside)) (c: fset atomicformula)
    requires { clauselist <> Nil }
    requires { is_unsatisfiable_clauselist clauselist }
    requires { not_empty_setc_clauselist clauselist }
    requires { not mem ABot c }
    requires { mem ATop c }
    requires { is_satisfiable_set c }
    ensures { mem ABot (algorithmA_spec clauselist c) }
    variant { length clauselist }
  = match clauselist with
    | Nil -> absurd
    | Cons (x,p) Nil -> assert { subset x c };
                        assert { (convertRStoAF p) = ABot }
    | Cons _ _ -> match findOneSubset clauselist c with
                  | None -> absurd
                  | Some (x,p) -> if eq_pos (convertRStoAF p) ABot then
                                      ()
                                  else
                                      unsat_induction_general (removeFromList (x,p) clauselist) (FS.add (convertRStoAF p) c)
                   
                  end
    end
    
  goal G2: false 
               
  lemma unsat_induction: forall clauselist.
    clauselist <> Nil /\
      is_unsatisfiable_clauselist clauselist /\
        not_empty_setc_clauselist clauselist ->
          mem ABot
               (algorithmA_spec clauselist (singleton ATop))
               
  let ghost function horn_logic (clauselist: list (fset atomicformula, rightside)) : bool
    requires { not_empty_setc_clauselist clauselist }
  = not (FS.mem ABot (algorithmA_spec clauselist (FS.singleton ATop)))
      
  lemma horn_sat_soundness:
    forall clauselist.
      is_satisfiable_clauselist clauselist /\ not_empty_setc_clauselist clauselist -> (horn_logic clauselist = true)
  
  lemma horn_unsat_soundness:
    forall clauselist.
      is_unsatisfiable_clauselist clauselist /\ not_empty_setc_clauselist clauselist -> (horn_logic clauselist = false)
  
  goal G3: false
  
  predicate a
  predicate b
  predicate c
  
  goal GG: ((a /\ b) -> c) <-> (((not c) /\ b) -> (not a))
  
  
  lemma not_unsat_set_sat_set:
    forall set.
       not is_unsatisfiable_set set <-> (exists f:i -> t. eval_setconjunction set f = top)
        
  lemma not_unsat_clause_sat_clause:
     forall clause.
      (not is_unsatisfiable_clause clause) <-> is_satisfiable_clause clause
  
  
  lemma not_unsat_sat:
    forall clauselist.
      (not is_unsatisfiable_clauselist clauselist) <-> is_satisfiable_clauselist clauselist
  
  lemma not_sat_unsat:
    forall clauselist.
      (not is_satisfiable_clauselist clauselist) <-> is_unsatisfiable_clauselist clauselist
 
  
  lemma horn_sat_completeness:
    forall clauselist.
      (horn_logic clauselist = true) /\ not_empty_setc_clauselist clauselist -> is_satisfiable_clauselist clauselist

  
  lemma horn_unsat_completeness:
    forall clauselist.
      (horn_logic clauselist = false) /\ not_empty_setc_clauselist clauselist -> is_unsatisfiable_clauselist clauselist

  
  (* lemma horn_true_sat:
    forall clauselist.
      (horn_logic clauselist = true) /\ not_empty_setc_clauselist clauselist -> is_satisfiable_clauselist clauselist *)
  
  
               
  (* END OF INDUCTION CASE *)
  
  
  (* PROGRAM *)
  
  goal G4: false
  
  
  
    
  (*let lemma mem_fset_then_mem_set (elem: (set, rightside)) (clauselist: list (set ,rightside))
    requires { let (set,p) = elem in
                ListMem.mem ((to_fset set), p) (listset_to_listfset clauselist) }
    ensures { let (set,p) = elem in
                ListMem.mem (set,p) clauselist }
  = ()*)
  
   goal G5: false

  
    
  
  
  goal G6: false
      

end

module Horn

  use TypeForm
  use Eval
  use import formula.ConjunctiveNormalForm as CNF
  use import formula.Horn as HornFormula
  use list.Mem as ListMem
  use list.List, list.Append, list.Length, list.HdTl, list.Permut, list.NumOcc, list.Distinct

  use booltheory.BoolImplementation, int.Int, setstheory.BoolSet, setstheory.PropositionalFormulaSet, option.Option
  use Converts
  use import set.Fset as FS
  use SetAppAF
  use Horn_Logic
  use SAT

  function listset_to_listfset (clauselist: list (set, rightside))
                          : list (fset atomicformula, rightside)
  = match clauselist with
      | Nil -> Nil
      | Cons (setc, p) l -> Cons (to_fset setc, p) (listset_to_listfset l)
    end
    meta rewrite_def function listset_to_listfset
    
  lemma length_equal_listset_to_list_fset:
    forall cl.
      length cl = length (listset_to_listfset cl)
    
  function listfset_to_listset (clauselist: list (fset atomicformula, rightside))
                          : list (set, rightside)
  = match clauselist with
      | Nil -> Nil
      | Cons (setc, p) l -> Cons (mk (setc), p) (listfset_to_listset l)
    end
    meta rewrite_def function listfset_to_listset
    
    
  predicate not_subset (clauselist: list (set,rightside))
                                    (c: set)
  = match clauselist with
      | Nil -> true
      | Cons (setc,_) l -> (not subset setc c) /\
                              not_subset l c
     end 
   

  val findOneSubset_prog (clauselist: list (set ,rightside)) 
                         (c: set) 
                         : option (set ,rightside)
  ensures { match result with
            | None -> match  findOneSubset (listset_to_listfset clauselist) c with
                      | None -> true
                      | Some _ -> false
                      end
            | Some (setc,p) -> Some (to_fset setc, p) = findOneSubset (listset_to_listfset clauselist) c
            end
          }
          
  predicate variable_in_clauselist_program (variable: atomicformula) (clauselist: list (set,rightside))
  = variable <> ABot /\ variable <> ATop ->
      match clauselist with
        | Nil -> false
        | Cons (setc,p) cl -> if (((convertRStoAF p) = variable) || (mem variable setc)) then
                                true
                              else
                                variable_in_clauselist_program variable cl
        end
        
        
  let rec removeFromList_prog (elem: (set, rightside)) (clauselist: list (set, rightside)) : list (set, rightside)
    ensures { let (set,p) = elem in
                listset_to_listfset result = (removeFromList ((to_fset set),p) (listset_to_listfset clauselist)) }
    variant { length clauselist }
  = match clauselist with
    | Nil -> Nil
    | Cons (s1,p1) l -> let (s2,p2) = elem in
      if (s1 == s2 && rs_eq_pos p1 p2) then l else Cons (s1,p1) (removeFromList_prog elem l)
    end
  
    
  let rec algorithmA (clauselist: list (set ,rightside))
                              (c: set) : set
    requires{ mem ATop c }
    requires{ not mem ABot c }
    requires{ is_satisfiable_set c }
    ensures { subset c result }
    ensures { to_fset result = algorithmA_spec (listset_to_listfset clauselist) (to_fset c) }
    (*ensures { subset (diff result c) (add ATop (add ABot (set_smb_clauselist clauselist))) }*)
    variant { length clauselist }
  = match clauselist with
    | Nil -> c
    | Cons _ _ ->  match findOneSubset_prog clauselist c with
                   | None -> c
                   | Some (s,p) -> if eq_pos (convertRStoAF p) ABot then
                                      (add ABot c)
                                   else
                                      algorithmA (removeFromList_prog (s,p) clauselist) (add (convertRStoAF p) c)
                   end
    end
  
  
  
  let horn (clauselist: list (set ,rightside)) : bool
    requires { not_empty_setc_clauselist (listset_to_listfset clauselist) }
    ensures { result = horn_logic (listset_to_listfset clauselist) }
  = not (mem ABot (algorithmA clauselist (singleton ATop)))
  
          
end
